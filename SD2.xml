<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE muclient>
<!-- Saved on Saturday, July 05, 2008, 4:46 PM -->
<muclient>
<plugin name="Search_and_Destroy_v2" version="2.0"
	id="20000000cedd84f510b74715"
	date_written="2018-07-20 01:00:00" author="Starling" language="Lua" purpose="rock the casbah" requires="4.89" save_state="y"	>
<description trim="n">
<![CDATA[
	--[[ Search and Destroy version history:
	--	 1.0  - WinkleWinkle	Original author of S&D, the first (and to this day, only) campaign accelerator script to be publicly available.
	--	 1.1  - Nokfah			Resolved a compatibility issue when a mapper update rendered 1.0 inoperable.  Originally versioned "2.8".
	--	 1.2  - Lunk			Briefly took over hosting in early 2017.  Banned on 27 Apr for reasons not related to S&D.
	--	 1.3  - Starling		Active developer and problem fixer as of 1 Jun 2017.  v1.3.0 was the first true update (bugfixes 
	--							and features) since S&D came out nearly 9 years before.  Updates continued through v1.3.5.
	--   2.0  - Starling		S&D unified to be one plugin, removing the 3-plugin system's many inherent probems.  v2.0-beta was released on 23 Jul 2018.
	--
	-- 	Happy hunting, ninjas. --]]
]]>
</description>
</plugin>

<!-- Isolinear intermatrix (utility module) -->
<include name="constants.lua"/>
<variables><variable name="example"></variable></variables>
<timers>
	<timer name="tim_init_plugin"
		second="1.0" active_closed="y"
		script="init_plugin" 
		enabled="y" send_to="12" > </timer>
		
	<timer name="execute_in_area_timer"
		second="0.25" 
		script="execute_in_area_tick"
		enabled="n" > </timer>
</timers>

<script>
<![CDATA[
	-- total lines of code: 4143	(at start of merge)
	-- total lines of code: ____	(at end of merge)
	require "gmcphelper"
	require "movewindow"	-- require line offset: 113
	require "mw"
	require "serialize"
	require "tprint"
	require "wait"
	local current_sd_version = "Search & Destroy v2.0 (rel-beta 9)"
	local plugin_id_gmcp_handler = "3e7dedbe37e44942dd46d264"		-- easier to remember the var names than the plugin id's
	local plugin_id_gmcp_mapper = "b6eae87ccedd84f510b74714"
	local plugin_id_z_order = "462b665ecb569efbf261422f"
	
-- Current, previous room data GMCP_room_info
	local currentRoom = { 	rmid = gmcp("room.info.num"), 
							arid = gmcp("room.info.zone"), 
							maze = (string.match(gmcp("room.info.details"), "maze") == "maze") and "yes" or "no",
							exits = gmcp("room.info.exits"), }	or { rmid = "-1", arid = "-1", maze = "no", exits = {} }
	local previousRoom = { rmid = "-2", arid = "-2", maze = "no", exits = {} }
-- player status, cp eligibility, etc.
	local char_state = "1"		
	local player_on_cp = "no"
	local new_cp_current_level = "yes"
-- Execute in area
	local execute_in_area_array = {}
-- quest details
	local quest_target_details = {qmob = "", area = "", room = ""}
-- campaign details (type, level, targets)
	local cp_level = tonumber(GetVariable("mcvar_cp_level")) or 0	-- campaign status, etc. variables
	local cp_type = GetVariable("mcvar_cp_type") or "none"
	local cp_target_list = {}
-- campaign data processing
	local cp_check_list = {}
	local cp_check_index = 1
	local cp_info_targets = {}
	local cp_info_index = 1
	local gotoList = {}	-- list of room id's used by go, nx, nx-
	local gotoIndex = 1
	local last_cp_check = os.clock()
	local xcp_index = 0
	local xcp_retry_stat = 0
	local xcp_target = {}
	
-- automatic noexp
	local auto_noexp_tnl = tonumber(GetVariable("mcvar_auto_noexp_tnl")) or 0	-- low TNL cutoff, if you can request a cp at current level. If not, allows you to level up.
	local noexp_onoff = "off"
-- Variables from Mapper Extender
	local area_range = {}
	local areaStartRooms = {}
	local last_area = ""
	local mapper_area_index = 0
	local next_room = -1
	local showDebug = 0
	local speed = "run"
	local start_room_type
	local CONFIG_show_help = "true"
	local CONFIG_xset_vidblain = GetVariable("mcvar_xset_vidblain_onoff") or "off"
	local CONFIG_xcp_mode = GetVariable("mcvar_CONFIG_xcp_mode") or "ht"
	-- Variables from Search and Destroy
	local autoHuntData
	local autoHuntMob = ""
	local full_mob_name = ""
	local HuntFoundIndex = 1
	local dir_map = { north = "n", south = "s", east = "e", west = "w", up = "u", down = "d" }
	local is_exact = 0
	local quick_kill_command = GetVariable("mcvar_quick_kill_command") or "k"
	local short_mob_name = ""
	local whereTrickFullMob = ""
	local whereTrickIndex = 0
	local whereTrickMob = ""
	local whereTrickNextIndex = 0
	local whereTrickNextMob = ""
	
	-- S&D GUI window data
	local win = "sd_window_" .. GetPluginID()
	local windowinfo
	local background_colour = ColourNameToRGB("black")
	-- resizing constraints
	RESIZE_TAG_SIZE = 15		-- Size of the zone for resizing via drag
	REFRESH_DELAY = 0.02--0.066		-- Controls delay between Redraws while resizing.
	local win_minimum_width = 320
	local win_minimum_height = 40+RESIZE_TAG_SIZE
	local win_width = tonumber(GetVariable("mcvar_xgui_WinSizeX")) or 320			-- window dimensions
	local win_height = tonumber(GetVariable("mcvar_xgui_WinSizeY")) or 280
	local pos_x = tonumber(GetVariable("mcvar_xgui_WinPosX")) or 0			-- window position x,y coordinates
	local pos_y = tonumber(GetVariable("mcvar_xgui_WinPosY")) or 0
	local win_height_minimized = 49			-- window dimensions min/max
	local win_width_minimized = win_minimum_width
	local win_width_maximized = tonumber(GetVariable("mcvar_xgui_WinMaxX")) or win_width_minimized
	local win_height_maximized = tonumber(GetVariable("mcvar_xgui_WinMaxY")) or 280
	local win_state = GetVariable("mcvar_xgui_WinState") or "max"
	local win_init = false
	-- position where cp target list starts; line spacing between list items
	local offset = 36
	local line_spacing = tonumber(GetVariable("mcvar_xgui_line_spacing")) or 15
	local cplist_font_size = tonumber(GetVariable("mcvar_xgui_font_size")) or 8
	local hotspots = {}
	local itemHotspots = {}
	local USER_qq_report_channel = "gt" 			-- group tell
-- Area and room data
	
	function OnPluginBroadcast(msg, id, name, text)
		if (id == plugin_id_gmcp_handler) then	-- check to ensure data is coming from GMCP handler and not something else
			if (text == "char.status") then		-- get current character status
				char_state = gmcp("char.status.state")
			elseif (text == "room.info") then	-- get room info
				--prev_room_rmid = curr_room_rmid or -1
				--prev_room_arid = curr_room_arid or ""
				--prev_room_maze = curr_room_maze or "no"
				--curr_room_rmid = gmcp("room.info.num")
				--curr_room_arid = gmcp("room.info.zone")
				--curr_room_maze = (string.match(gmcp("room.info.details"), "maze") == "maze") and "yes" or "no"
				local r = gmcp("room.info")
				r.maze = (string.match(r.details, "maze") == "maze") and "yes" or "no"
					previousRoom = currentRoom or {}
					currentRoom = { rmid = r.num, arid = r.zone, exits = r.exits, maze = r.maze } or {}
					if (previousRoom.rmid ~= nil) and (currentRoom.rmid ~= nil) then
					end
			elseif (text == "comm.quest") then	-- get quest info
				local q = gmcp("comm.quest")
				if (q.action == "start") or (q.action == "status" and (q.timer)) then
					quest_target_details = {qmob = q.targ, area = q.area, room = q.room}
					xcp_index = 0											-- clear index from 'xcp' for the same reason
					--q.room = string.gsub(q.room, "@[bcgmrwyBCDGMRWY]", "") or ""	-- clean out ANSI color codes	--cleanRoom = string.gsub(room, "@x[\d]+", "") -- clean out Xterm color codes	
					Execute("xm {" .. q.targ .. "} " .. q.room .. "|" .. q.area)
					set_full_mob_name(q.targ, "comm.quest")	
					set_short_mob_name(guess_mob_keywords(q.targ), "comm.quest")	-- broadcast short mob name
					set_is_exact(1, "comm.quest")
					xcp_index = 0
					xgui_RefreshWindow()
				elseif (q.action == "status" and (q.wait)) then
					ColourNote("#FF5000", "", "\nSearch and Destroy: You must wait before requesting a new quest.\n")
				end
			elseif (text == "config") then		-- get config data, needed for automatic noexp
				noexp_onoff = (gmcp("config.noexp") == "YES") and "on" or "off"
			end
		end
	end
	function OnPluginInstall()
		ColourNote("SteelBlue", "", "\n+=================================================================+")
		ColourNote("SteelBlue", "", "   " .. current_sd_version .. " installed at " .. os.time() )
		ColourNote("SteelBlue", "", "+=================================================================+\n")
		-- install the window movement handler, get window position, and display the window.
		windowinfo = movewindow.install (win, miniwin.pos_center, miniwin.create_absolute_location, false, nil, {mouseup=MouseUp, mousedown=LeftClickOnly, dragmove=LeftClickOnly, dragrelease=LeftClickOnly},{x=pos_x, y=pos_y})
		create_win()
	end
	
	local init_called = 0
	function init_plugin()
		if not IsConnected() then return end
		if ((char_state ~= "3") and (char_state ~= "8") and (char_state ~= "9") and (char_state ~= "11")) then
			Send_GMCP_Packet("request char")
			return
		end
		if (init_called == 0) then
			init_called = 1
			Execute("xset suspend page size")
		elseif (init_called == 1) then
			EnableTimer("tim_init_plugin", false)
			init_called = 2
			SendNoEcho("area keywords 1 300")
		end
	end
	
-- *** former plugin - Mapper Extender *** -->
	--local areaIndex = {}
	--local last_substitute
	--local searchIndex = 0
	--local searchResult = {}
	--local showPK = GetVariable("showPK") or "true"
	--local xrunto_area_id
	--local USER_run_if_one_room = true
	if (GetVariable("areaStartRooms") ~= nil) then			
		luastmt = "obj = " .. GetVariable("areaStartRooms")
		assert (loadstring (luastmt or "")) ()		
		areaStartRooms = obj
	end	
	
-- 	Default area start rooms when there is no xset mark:
	local areaDefaultStartRooms = {			
		["abend"] 		= { roomid = "24909", ct = "3" },		-- Continents
		["alagh"] 		= { roomid =  "3224", ct = "4" },
		["gelidus"] 	= { roomid = "18780", ct = "2" },
		["mesolar"] 	= { roomid = "12664", ct = "0" },
		["southern"] 	= { roomid =  "5192", ct = "1" },
		["uncharted"] 	= { roomid =  "7701", ct = "5" },
		["vidblain"] 	= { roomid = "33570", ct = "6" },
	
		["aardington"] 	= { roomid = "47509" },		-- A --
		["academy"] 	= { roomid = "35233" },
		["adaldar"] 	= { roomid = "34400" },
		["afterglow"] 	= { roomid = "38134" },
		["agroth"] 		= { roomid = "11027" },
		["ahner"] 		= { roomid = "30129" },
		["alehouse"] 	= { roomid =   "885" },
		["amazon"] 		= { roomid =  "1409" },
		["amusement"] 	= { roomid = "29282" },
		["andarin"] 	= { roomid =  "2399" },
		["annwn"] 		= { roomid = "28963" },
		["anthrox"] 	= { roomid =  "3993" }, 
		["arboretum"] 	= { roomid = "39100" }, 
		["arena"] 		= { roomid = "25768" },
		["arisian"] 	= { roomid = "28144" },
		["ascent"] 		= { roomid = "43161" },
		["astral"] 		= { roomid = "27882" },
		["atlantis"] 	= { roomid = "10573" },
		["autumn"] 		= { roomid = "13839" },
		["avian"] 		= { roomid =  "4334" },
		["aylor"] 		= { roomid = "32418" },
		["bazaar"] 		= { roomid = "34454" },		-- B --
		["beer"] 		= { roomid = "20062" },
		["believer"] 	= { roomid = "25940" },
		["blackrose"] 	= { roomid =  "1817" },
		["bliss"] 		= { roomid = "29988" },
		["bonds"] 		= { roomid = "23411" },
		["caldera"] 	= { roomid = "26341" },		-- C --
		["callhero"] 	= { roomid = "33031" },
		["camps"] 		= { roomid =  "4714" },
		["canyon"] 		= { roomid = "25551" },
		["caravan"] 	= { roomid = "16071" },
		["cards"] 		= { roomid =  "6255" },
		["carnivale"] 	= { roomid = "28635" },
		["cataclysm"] 	= { roomid = "19976" },
		["cathedral"] 	= { roomid = "27497" },
		["cats"] 		= { roomid = "40900" },
		["chasm"] 		= { roomid = "29446" },
		["chessboard"]	= { roomid = "25513" },
		["childsplay"] 	= { roomid =   "678" },
		["cineko"] 		= { roomid =  "1507" },
		["citadel"] 	= { roomid = "14963" },
		["conflict"] 	= { roomid = "27711" },
		["coral"] 		= { roomid =  "4565" },
		["cougarian"] 	= { roomid = "14311" },
		["cove"] 		= { roomid = "49941" },
		["cradle"] 		= { roomid = "11267" },
		["crynn"] 		= { roomid = "43800" },
		["damned"] 		= { roomid = "10469" },		-- D --
		["darklight"] 	= { roomid = "19642" },
		["darkside"] 	= { roomid = "15060" },
		["ddoom"] 		= { roomid =  "4193" },
		["deadlights"] 	= { roomid = "16856" },
		["deathtrap"] 	= { roomid =  "1767" },
		["deneria"] 	= { roomid = "35006" },
		["desert"] 		= { roomid = "20186" },
		["desolation"] 	= { roomid = "19532" },
		["dhalgora"] 	= { roomid = "16755" },
		["diatz"] 		= { roomid =  "1254" },
		["diner"] 		= { roomid = "36700" },
		["dortmund"] 	= { roomid = "16577" },
		["drageran"] 	= { roomid = "25894" },
		["dread"] 		= { roomid = "26075" },
		["dsr"] 		= { roomid = "30030" },
		["dundoom"] 	= { roomid = "25661" },
		["dunoir"] 		= { roomid = "14222" },
		["duskvalley"] 	= { roomid = "37301" },
		["dynasty"] 	= { roomid = "30799" },
		["earthlords"] 	= { roomid = "42000" },		-- E --
		["earthplane"] 	= { roomid =  "1354" },
		["elemental"] 	= { roomid = "41624" },
		["empire"] 		= { roomid = "32203" },
		["empyrean"] 	= { roomid = "14042" },
		["entropy"] 	= { roomid = "29773" },
		["fantasy"] 	= { roomid = "15205" },		-- F --
		["farm"] 		= { roomid = "10676" },
		["fayke"] 		= { roomid = "30418" },
		["fens"] 		= { roomid = "16528" },
		["fields"] 		= { roomid = "29232" },
		["firebird"] 	= { roomid = "32885" },
		["firenation"] 	= { roomid = "41879" },
		["fireswamp"] 	= { roomid = "34755" },
		["fortress"] 	= { roomid = "31835" },
		["fortune"] 	= { roomid = "38561" },
		["fractured"] 	= { roomid = "17033" },
		["ft1"] 		= { roomid =  "1205" },
		["ftii"] 		= { roomid = "26673" },
		["gallows"] 	= { roomid =  "4344" },		-- G --
		["gathering"] 	= { roomid = "36451" },
		["gauntlet"] 	= { roomid = "31652" },
		["geniewish"] 	= { roomid = "38464" },
		["gilda"] 		= { roomid =  "4243" },
		["glamdursil"] 	= { roomid = "35055" },
		["glimmerdim"] 	= { roomid = "26252" },
		["gnomalin"] 	= { roomid = "34397" },
		["goldrush"] 	= { roomid = "15014" },
		["graveyard"] 	= { roomid = "28918" },
		["greece"] 		= { roomid =  "2089" },
		["gwillim"] 	= { roomid = "25974" },
		["hades"] 		= { roomid = "29161" },		-- H --
		["hatchling"]	= { roomid = "34670" },
		["hawklord"] 	= { roomid = "40550" },
		["hedge"] 		= { roomid = "15146" },
		["helegear"] 	= { roomid = "30699" },
		["hell"] 		= { roomid = "30984" },
		["hoard"] 		= { roomid =  "1675" },
		["hodgepodge"] 	= { roomid = "30469" },
		["horath"] 		= { roomid =    "91" },
		["horizon"] 	= { roomid = "31959" },
		["icefall"] 	= { roomid = "38701" },		-- I --
		["illoria"] 	= { roomid = "10420" },
		["imagi"] 		= { roomid = "36800" },
		["imperial"] 	= { roomid = "16966" },
		["infamy"] 		= { roomid = "26641" },
		["infest"] 		= { roomid = "16165" },
		["insan"] 		= { roomid =  "6850" },
		["jenny"] 		= { roomid = "29637" },		-- J --
		["jotun"] 		= { roomid = "31508" },
		["kearvek"] 	= { roomid = "29722" },		-- K --
		["kerofk"] 		= { roomid = "16405" },
		["ketu"] 		= { roomid = "35114" },
		["kingsholm"] 	= { roomid = "27522" },
		["knossos"] 	= { roomid = "28193" },
		["kobaloi"] 	= { roomid = "10691" },
		["kultiras"] 	= { roomid = "31161" },
		["lab"] 		= { roomid = "28684" },		-- L --
		["labyrinth"] 	= { roomid = "31405" },
		["lagoon"] 		= { roomid = "30549" },
		["landofoz"] 	= { roomid =   "510" },
		["laym"] 		= { roomid =  "6005" },
		["legend"] 		= { roomid = "16224" },
		["lemdagor"] 	= { roomid =  "1966" },
		["lidnesh"] 	= { roomid = "27995" },
		["livingmine"] 	= { roomid = "37008" },
		["longnight"] 	= { roomid = "26367" },
		["losttime"] 	= { roomid = "28584" },
		["lplanes"] 	= { roomid = "29364" },
		["maelstrom"] 	= { roomid = "38058" },		-- M --
		["manor"] 		= { roomid = "10621" },
		["masq"] 		= { roomid = "29840" },
		["mayhem"] 		= { roomid =  "1866" },
		["melody"] 		= { roomid = "14172" },
		["minos"] 		= { roomid = "20472" },
		["mistridge"] 	= { roomid =  "4491" },
		["monastery"] 	= { roomid = "15756" },
		["mudwog"] 		= { roomid =  "2347" },
		["nanjiki"] 	= { roomid = "11203" },		-- N --
		["necro"] 		= { roomid = "29922" },
		["nenukon"] 	= { roomid = "31784" },
		["newthalos"] 	= { roomid = "23853" },
		["ninehells"] 	= { roomid =  "4613" },
		["northstar"] 	= { roomid = "11127" },
		["nottingham"] 	= { roomid = "11077" },
		["nulan"] 		= { roomid = "37900" },
		["nursing"] 	= { roomid = "31977" },
		["nynewoods"] 	= { roomid = "23562" },
		["oceanpark"] 	= { roomid = "39600" },		-- O --
		["omentor"] 	= { roomid = "15579" },
		["ooku"] 		= { roomid = "39000" }, 
		["oradrin"] 	= { roomid = "25436" }, 
		["origins"] 	= { roomid = "35900" },
		["orlando"] 	= { roomid = "30331" },
		["paradise"] 	= { roomid = "29624" },		-- P --
		["partroxis"] 	= { roomid =  "5814" },
		["peninsula"] 	= { roomid = "35701" },
		["petstore"] 	= { roomid =   "995" },
		["pompeii"] 	= { roomid =    "57" },
		["promises"] 	= { roomid = "25819" },
		["prosper"] 	= { roomid = "28268" },
		["qong"] 		= { roomid = "16115" },		-- Q --
		["quarry"] 		= { roomid = "23510" },
		["radiance"] 	= { roomid = "19805" },		-- R --
		["raga"] 		= { roomid = "19861" },
		["raukora"] 	= { roomid =  "6040" },
		["rebellion"] 	= { roomid = "10305" },
		["remcon"] 		= { roomid = "25837" },
		["reme"] 		= { roomid = "32703" },
		["rosewood"] 	= { roomid =  "6901" },
		["ruins"] 		= { roomid = "16805" },
		["sagewood"] 	= { roomid = "28754" },		-- S --
		["sahuagin"] 	= { roomid = "34592" },
		["salt"] 		= { roomid =  "4538" },
		["sanctity"] 	= { roomid = "10518" },
		["sanctum"] 	= { roomid = "15307" },
		["sandcastle"] 	= { roomid = "37701" },
		["sanguine"] 	= { roomid = "15436" },
		["scarred"] 	= { roomid = "34036" },
		["sendhian"] 	= { roomid = "20288" },
		["sennarre"] 	= { roomid = "15491" },
		["shouggoth"] 	= { roomid = "34087" },
		["siege"] 		= { roomid = "43265" },
		["sirens"] 		= { roomid = "16298" },
		["slaughter"] 	= { roomid =  "1601" },
		["snuckles"] 	= { roomid =   "182" },
		["soh"] 		= { roomid = "25611" },
		["sohtwo"] 		= { roomid = "30752" },
		["solan"] 		= { roomid = "23713" },
		["songpalace"] 	= { roomid = "47013" },
		["spyreknow"] 	= { roomid = "34800" },
		["stone"] 		= { roomid = "11386" },
		["storm"] 		= { roomid =  "6304" },
		["stormhaven"] 	= { roomid = "20649" },
		["stronghold"] 	= { roomid = "20572" },
		["stuff"] 		= { roomid = "40400" },
		["takeda"] 		= { roomid = "15952" },		-- T --
		["talsa"] 		= { roomid = "26917" },
		["temple"] 		= { roomid = "31597" },
		["tanra"] 		= { roomid = "46913" },
		["terra"] 		= { roomid = "19679" },
		["terramire"] 	= { roomid =  "4493" },
		["thieves"] 	= { roomid =     "7" },
		["times"] 		= { roomid = "28463" },
		["tirna"] 		= { roomid = "20136" },
		["titan"] 		= { roomid = "38234" },
		["tol"] 		= { roomid = "16325" },
		["tombs"] 		= { roomid = "15385" },
		["umari"] 		= { roomid = "36601" },		-- U --
		["underdark"] 	= { roomid = "27341" },
		["uplanes"] 	= { roomid = "29364" },
		["uprising"] 	= { roomid = "15382" },
		["vale"] 		= { roomid =  "1036" },		-- V --
		["verdure"] 	= { roomid = "24090" },
		["verume"] 		= { roomid = "30607" },
		["village"] 	= { roomid = "30850" },
		["vlad"] 		= { roomid = "15970" },
		["volcano"] 	= { roomid =  "6091" },
		["weather"] 	= { roomid = "40499" },		-- W --
		["werewood"] 	= { roomid = "30956" },
		["wildwood"] 	= { roomid =   "322" },
		["winds"] 		= { roomid = "39900" },
		["winter"] 		= { roomid =  "1306" },
		["wizards"] 	= { roomid = "31316" },
		["wonders"] 	= { roomid = "32981" },
		["wooble"] 		= { roomid = "11335" },
		["woodelves"] 	= { roomid = "32199" },
		["wtc"] 		= { roomid = "37895" },
		["wyrm"] 		= { roomid = "28847" },
		["xmas"] 		= { roomid =  "6212" },		-- X --
		["xylmos"] 		= { roomid =   "472" },
		["yarr"] 		= { roomid = "30281" },
		["ygg"] 		= { roomid = "24186" },		-- Y --
		["yurgach"] 	= { roomid = "29450" },
		["zangar"] 		= { roomid =  "6164" },		-- Z --
		["zodiac"] 		= { roomid = "15857" },
		["zoo"] 		= { roomid =  "5920" },
		["zyian"] 		= { roomid =   "729" },
		-- Non-questable Areas
		["manor1"] 		= { roomid = "14460", noquest = true },		-- Manor areas
		["manor3"] 		= { roomid = "20836", noquest = true },
		["manorisle"] 	= { roomid =  "6366", noquest = true },
		["manormount"] 	= { roomid = "39449", noquest = true },
		["manorsea"] 	= { roomid = "35003", noquest = true },
		["manorville"] 	= { roomid = "35004", noquest = true },
		["manorwoods"] 	= { roomid = "35002", noquest = true },
		
		["badtrip"] 	= { roomid = "32877", noquest = true },		-- Other no-quest areas
		["birthday"]	= { roomid = "10920", noquest = true },
		["inferno"]		= { roomid =    "-1", noquest = true },
		["lowlands"] 	= { roomid = "28044", noquest = true },
		["seaking"]		= { roomid =    "-1", noquest = true },
		
		["amazonclan"] 	= { roomid = "34212", noquest = true },		-- Public clan halls
		["bard"] 		= { roomid = "30538", noquest = true },
		["bootcamp"] 	= { roomid = "49256", noquest = true },
		["cabal"] 		= { roomid = "15704", noquest = true },
		["chaos"] 		= { roomid = "28909", noquest = true },
		["crimson"] 	= { roomid = "27989", noquest = true },
		["crusaders"] 	= { roomid = "31122", noquest = true },
		["daoine"] 		= { roomid = "30949", noquest = true },
		["doh"] 		= { roomid = "16803", noquest = true },
		["dominion"] 	= { roomid =  "5863", noquest = true },
		["dragon"] 		= { roomid =   "642", noquest = true },
		["druid"] 		= { roomid = "29582", noquest = true },
		["emerald"] 	= { roomid =   "831", noquest = true },
		["gaardian"] 	= { roomid = "20026", noquest = true },
		["imperium"] 	= { roomid = "30415", noquest = true },
		["light"] 		= { roomid =  "2339", noquest = true },
		["loqui"] 		= { roomid = "28580", noquest = true },
		["masaki"] 		= { roomid = "15852", noquest = true },
		["perdition"] 	= { roomid = "19968", noquest = true },
		["pyre"] 		= { roomid = "15141", noquest = true },
		["romani"] 		= { roomid = "24180", noquest = true },
		["seekers"] 	= { roomid = "14165", noquest = true },
		["shadokil"] 	= { roomid = "32407", noquest = true },
		["tanelorn"] 	= { roomid = "31561", noquest = true },
		["tao"] 		= { roomid = "29210", noquest = true },
		["touchstone"] 	= { roomid = "28346", noquest = true },
		["twinlobe"] 	= { roomid = "15575", noquest = true },
		["vanir"] 		= { roomid =   "878", noquest = true },
		["watchmen"] 	= { roomid = "32342", noquest = true },
		
		["baal"] 		= { roomid =    "-1", noquest = true },		-- Closed clan halls
		["hook"] 		= { roomid =    "-1", noquest = true },
		["retri"] 		= { roomid =    "-1", noquest = true },
		["rhabdo"] 		= { roomid =    "-1", noquest = true },
		["rogues"] 		= { roomid =    "-1", noquest = true },
		["xunti"] 		= { roomid =    "-1", noquest = true },
		
		["challenge"]	= { roomid =    "-1", noquest = true },		-- Normally inaccessible areas, or which lack a sensible starting room.
		["immhomes"]	= { roomid =    "-1", noquest = true },
		["lasertwo"]	= { roomid =    "-1", noquest = true },
		["limbo"]		= { roomid =    "-1", noquest = true },
		["lualand"]		= { roomid =    "-1", noquest = true },
		["midgaard"]	= { roomid =    "-1", noquest = true },
		["oldclanone"] 	= { roomid =    "-1", noquest = true },
		["oldclantwo"] 	= { roomid =    "-1", noquest = true },
		["oldclanthr"] 	= { roomid =    "-1", noquest = true },
		["oldclanfou"] 	= { roomid =    "-1", noquest = true },
		["vault"]		= { roomid =    "-1", noquest = true },
		["warzone"]		= { roomid =    "-1", noquest = true },
		["wolfmaze"]	= { roomid =    "-1", noquest = true },	
	}
	local sd_area_data = {
		["A Genie's Last Wish"] = { arid = "geniewish" },
		["A Magical Hodgepodge"] = { arid = "hodgepodge" },
		["A Peaceful Giant Village"] = { arid = "village" },
		["Aardington Estate"] = { arid = "aardington" },
		["Aardwolf Zoological Park"] = { arid = "zoo" },
		["Adventures in Sendhia"] = { arid = "sendhian" },
		["Aerial City of Cineko"] = { arid = "cineko" },
		["Afterglow"] = { arid = "afterglow" },
		["Alagh, the Blood Lands"] = { arid = "alagh" },
		["All in a Fayke Day"] = { arid = "fayke" },
		["Ancient Greece"] = { arid = "greece" },
		["Andolor's Ocean Adventure Park"] = { arid = "oceanpark" },
		["Annwn"] = { arid = "annwn" },
		["Anthrox"] = { arid = "anthrox" },
		["Arboretum"] = { arid = "arboretum" },
		["Arisian Realm"] = { arid = "arisian" },
		["Art of Melody"] = { arid = "melody" },
		["Artificer's Mayhem"] = { arid = "mayhem" },
		["Ascension Bluff Nursing Home"] = { arid = "nursing" },
		["Atlantis"] = { arid = "atlantis" },
		["Avian Kingdom"] = { arid = "avian" },
		["Battlefields of Adaldar"] = { arid = "adaldar" },
		["Black Lagoon"] = { arid = "lagoon" },
		["Black Rose"] = { arid = "blackrose" },
		["Brightsea and Glimmerdim"] = { arid = "glimmerdim" },
		["Canyon Memorial Hospital"] = { arid = "canyon" },
		["Castle Vlad-Shamir"] = { arid = "vlad" },
		["Chaprenula's Laboratory"] = { arid = "lab" },
		["Child's Play"] = { arid = "childsplay" },
		["Christmas Vacation"] = { arid = "xmas" },
		["Cloud City of Gnomalin"] = { arid = "gnomalin" },
		["Cradlebrook"] = { arid = "cradle" },
		["Crossroads of Fortune"] = { arid = "fortune" },
		["Crynn's Church"] = { arid = "crynn" },
		["Dark Elf Stronghold"] = { arid = "stronghold" },
		["Death's Manor"] = { arid = "manor" },
		["Deathtrap Dungeon"] = { arid = "deathtrap" },
		["Den of Thieves"] = { arid = "thieves" },
		["Descent to Hell"] = { arid = "hell" },
		["Desert Doom"] = { arid = "ddoom" },
		["Dhal'Gora Outlands"] = { arid = "dhalgora" },
		["Diamond Soul Revelation"] = { arid = "dsr" },
		["Dortmund"] = { arid = "dortmund" },
		["Dread Tower"] = { arid = "dread" },
		["Dusk Valley"] = { arid = "duskvalley" },
		["Earth Plane 4"] = { arid = "earthplane" },
		["Elemental Chaos"] = { arid = "elemental" },
		["Empyrean, Streets of Downfall"] = { arid = "empyrean" },
		["Entrance to Hades"] = { arid = "hades" },
		["Eternal Autumn"] = { arid = "autumn" },
		["Faerie Tales II"] = { arid = "ftii" },
		["Faerie Tales"] = { arid = "ft1" },
		["Fantasy Fields"] = { arid = "fantasy" },
		["Foolish Promises"] = { arid = "promises" },
		["Fort Terramire"] = { arid = "terramire" },
		["Gallows Hill"] = { arid = "gallows" },
		["Gelidus"] = { arid = "gelidus" },
		["Giant's Pet Store"] = { arid = "petstore" },
		["Gilda And The Dragon"] = { arid = "gilda" },
		["Gnoll's Quarry"] = { arid = "quarry" },
		["Gold Rush"] = { arid = "goldrush" },
		["Guardian's Spyre of Knowledge"] = { arid = "spyreknow" },
		["Gypsy Caravan"] = { arid = "caravan" },
		["Halls of the Damned"] = { arid = "damned" },
		["Hatchling Aerie"] = { arid = "hatchling" },
		["Hedgehogs' Paradise"] = { arid = "hedge" },
		["Helegear Sea"] = { arid = "helegear" },
		["Hotel Orlando"] = { arid = "orlando" },
		["House of Cards"] = { arid = "cards" },
		["Icefall"] = { arid = "icefall" },
		["Imagi's Nation"] = { arid = "imagi" },
		["Imperial Nation"] = { arid = "imperial" },
		["Insanitaria"] = { arid = "insan" },
		["Into the Long Night"] = { arid = "longnight" },
		["Intrigues of Times Past"] = { arid = "times" },
		["Island of Lost Time"] = { arid = "losttime" },
		["Jenny's Tavern"] = { arid = "jenny" },
		["Jotunheim"] = { arid = "jotun" },
		["Jungles of Verume"] = { arid = "verume" },
		["Keep of the Kobaloi"] = { arid = "kobaloi" },
		["Kerofk"] = { arid = "kerofk" },
		["Ketu Uplands"] = { arid = "ketu" },
		["Kiksaadi Cove"] = { arid = "cove" },
		["Kimr's Farm"] = { arid = "farm" },
		["Kingdom of Ahner"] = { arid = "ahner" },
		["Kingsholm"] = { arid = "kingsholm" },
		["Kobold Siege Camp"] = { arid = "siege" },
		["Kul Tiras"] = { arid = "kultiras" },
		["Land of Legend"] = { arid = "legend" },
		["Living Mines of Dak'Tai"] = { arid = "livingmine" },
		["Masquerade Island"] = { arid = "masq" },
		["Mount duNoir"] = { arid = "dunoir" },
		["Mudwog's Swamp"] = { arid = "mudwog" },
		["Nanjiki Ruins"] = { arid = "nanjiki" },
		["Nebulous Horizon"] = { arid = "horizon" },
		["Necromancers' Guild"] = { arid = "necro" },
		["Nenukon and the Far Country"] = { arid = "nenukon" },
		["New Thalos"] = { arid = "newthalos" },
		["Northstar"] = { arid = "northstar" },
		["Nottingham"] = { arid = "nottingham" },
		["Olde Worlde Carnivale"] = { arid = "carnivale" },
		["Onyx Bazaar"] = { arid = "bazaar" },
		["Ookushka Garrison"] = {arid = "ooku" },
		["Paradise Lost"] = { arid = "paradise" },
		["Plains of Nulan'Boar"] = { arid = "nulan" },
		["Pompeii"] = { arid = "pompeii" },
		["Prosper's Island"] = { arid = "prosper" },
		["Qong"] = { arid = "qong" },
		["Radiance Woods"] = { arid = "radiance" },
		["Raganatittu"] = { arid = "raga" },
		["Realm of Deneria"] = { arid = "deneria" },
		["Realm of the Firebird"] = { arid = "firebird" },
		["Realm of the Sacred Flame"] = { arid = "firenation" },
		["Realm of the Zodiac"] = { arid = "zodiac" },
		["Rebellion of the Nix"] = { arid = "rebellion" },
		["Rosewood Castle"] = { arid = "rosewood" },
		["Sagewood Grove"] = { arid = "sagewood" },
		["Sanctity of Eternal Damnation"] = { arid = "sanctity" },
		["Sen'narre Lake"] = { arid = "sennarre" },
		["Seven Wonders"] = { arid = "wonders" },
		["Sheila's Cat Sanctuary"] = { arid = "cats" },
		["Sho'aram, Castle in the Sand"] = { arid = "sandcastle" },
		["Siren's Oasis Resort"] = { arid = "sirens" },
		["Snuckles Village"] = { arid = "snuckles" },
		["Storm Mountain"] = { arid = "storm" },
		["Storm Ships of Lem-Dagor"] = { arid = "lemdagor" },
		["Sundered Vale"] = { arid = "vale" },
		["Swordbreaker's Hoard"] = { arid = "hoard" },
		["Tairayden Peninsula"] = { arid = "peninsula" },
		["Tai'rha Laym"] = { arid = "laym" },
		["Takeda's Warcamp"] = { arid = "takeda" },
		["Tanra'vea"] = { arid = "tanra" },
		["Thandeld's Conflict"] = { arid = "conflict" },
		["The Abyssal Caverns of Sahuagin"] = { arid = "sahuagin" },
		["The Amazon Nation"] = { arid = "amazon" },
		["The Amusement Park"] = { arid = "amusement" },
		["The Archipelago of Entropy"] = { arid = "entropy" },
		["The Astral Travels"] = { arid = "astral" },
		["The Aylorian Academy"] = { arid = "academy" },
		["The Blighted Tundra of Andarin"] = { arid = "andarin" },
		["The Blood Opal of Rauko'ra"] = { arid = "raukora" },
		["The Blood Sanctum"] = { arid = "sanctum" },
		["The Broken Halls of Horath"] = { arid = "horath" },
		["The Call of Heroes"] = { arid = "callhero" },
		["The Cataclysm"] = { arid = "cataclysm" },
		["The Chasm and The Catacombs"] = { arid = "chasm" },
		["The Chessboard"] = { arid = "chessboard" },
		["The Continent of Mesolar"] = { arid = "mesolar" },
		["The Coral Kingdom"] = { arid = "coral" },
		["The Cougarian Queendom"] = { arid = "cougarian" },
		["The Council of the Wyrm"] = { arid = "wyrm" },
		["The Covenant of Mistridge"] = { arid = "mistridge" },
		["The Cracks of Terra"] = { arid = "terra" },
		["The Curse of the Midnight Fens"] = { arid = "fens" },
		["The Dark Continent, Abend"] = { arid = "abend" },
		["The Dark Temple of Zyian"] = { arid = "zyian" },
		["The DarkLight"] = { arid = "darklight" },
		["The Darkside of the Fractured Lands"] = { arid = "darkside" },
		["The Deadlights"] = { arid = "deadlights" },
		["The Desert Prison"] = { arid = "desert" },
		["The Drageran Empire"] = { arid = "drageran" },
		["The Dungeon of Doom"] = { arid = "dundoom" },
		["The Earth Lords"] = { arid = "earthlords" },
		["The Eighteenth Dynasty"] = { arid = "dynasty" },
		["The Empire of Aiighialla"] = { arid = "empire" },
		["The Empire of Talsa"] = { arid = "talsa" },
		["The Fabled City of Stone"] = { arid = "stone" },
		["The Fire Swamp"] = { arid = "fireswamp" },
		["The First Ascent"] = { arid = "ascent" },
		["The Flying Citadel"] = { arid = "citadel" },
		["The Forest of Li'Dnesh"] = { arid = "lidnesh" },
		["The Fractured Lands"] = { arid = "fractured" },
		["The Gathering Horde"] = { arid = "gathering" },
		["The Gauntlet"] = { arid = "gauntlet" },
		["The Gladiator's Arena"] = { arid = "arena" },
		["The Glamdursil"] = { arid = "glamdursil" },
		["The Goblin Fortress"] = { arid = "fortress" },
		["The Grand City of Aylor"] = { arid = "aylor" },
		["The Graveyard"] = { arid = "graveyard" },
		["The Great City of Knossos"] = { arid = "knossos" },
		["The Great Salt Flats"] = { arid = "salt" },
		["The Icy Caldera of Mauldoon"] = { arid = "caldera" },
		["The Imperial City of Reme"] = { arid = "reme" },
		["The Infestation"] = { arid = "infest" },
		["The Keep of Kearvek"] = { arid = "kearvek" },
		["The Killing Fields"] = { arid = "fields" },
		["The Labyrinth"] = { arid = "labyrinth" },
		["The Land of Oz"] = { arid = "landofoz" },
		["The Land of the Beer Goblins"] = { arid = "beer" },
		["The Lower Planes"] = { arid = "lplanes" },
		["The Maelstrom"] = { arid = "maelstrom" },
		["The Marshlands of Agroth"] = { arid = "agroth" },
		["The Misty Shores of Yarr"] = { arid = "yarr" },
		["The Monastery"] = { arid = "monastery" },
		["The Mountains of Desolation"] = { arid = "desolation" },
		["The Nine Hells"] = { arid = "ninehells" },
		["The Nyne Woods"] = { arid = "nynewoods" },
		["The Old Cathedral"] = { arid = "cathedral" },
		["The Palace of Song"] = { arid = "songpalace" },
		["The Partroxis"] = { arid = "partroxis" },
		["The Path of the Believer"] = { arid = "believer" },
		["The Realm of Infamy"] = { arid = "infamy" },
		["The Realm of the Hawklords"] = { arid = "hawklord" },
		["The Relinquished Tombs"] = { arid = "tombs" },
		["The Reman Conspiracy"] = { arid = "remcon" },
		["The Ruins of Diamond Reach"] = { arid = "ruins" },
		["The Ruins of Stormhaven"] = { arid = "stormhaven" },
		["The Sanguine Tavern"] = { arid = "sanguine" },
		["The Scarred Lands"] = { arid = "scarred" },
		["The School of Horror"] = { arid = "soh" },
		["The Shadows of Minos"] = { arid = "minos" },
		["The Silver Volcano"] = { arid = "volcano" },
		["The Slaughter House"] = { arid = "slaughter" },
		["The Southern Ocean"] = { arid = "southern" },
		["The Stuff of Shadows"] = { arid = "stuff" },
		["The Temple of Shal'indrael"] = { arid = "temple" },
		["The Temple of Shouggoth"] = { arid = "shouggoth" },
		["The Three Pillars of Diatz"] = { arid = "diatz" },
		["The Titans' Keep"] = { arid = "titan" },
		["The Tournament of Illoria"] = { arid = "illoria" },
		["The Town of Solan"] = { arid = "solan" },
		["The Tree of Life"] = { arid = "tol" },
		["The Trouble with Gwillimberry"] = { arid = "gwillim" },
		["The Uncharted Oceans"] = { arid = "uncharted" },
		["The UnderDark"] = { arid = "underdark" },
		["The Upper Planes"] = { arid = "uplanes" },
		["The Uprising"] = { arid = "uprising" },
		["The Were Wood"] = { arid = "werewood" },
		["The Witches of Omen Tor"] = { arid = "omentor" },
		["The Wobbly Woes of Woobleville"] = { arid = "wooble" },
		["The Wood Elves of Nalondir"] = { arid = "woodelves" },
		["The Yurgach Domain"] = { arid = "yurgach" },
		["Tir na nOg"] = { arid = "tirna" },
		["Tournament Camps"] = { arid = "camps" },
		["Tribal Origins"] = { arid = "origins" },
		["Tumari's Diner"] = { arid = "diner" },
		["Umari's Castle"] = { arid = "umari" },
		["Unearthly Bonds"] = { arid = "bonds" },
		["Verdure Estate"] = { arid = "verdure" },
		["Vidblain, the Ever Dark"] = { arid = "vidblain" },
		["War of the Wizards"] = { arid = "wizards" },
		["Warrior's Training Camp"] = { arid = "wtc" },
		["Wayward Alehouse"] = { arid = "alehouse" },
		["Weather Observatory"] = { arid = "weather" },
		["Wedded Bliss"] = { arid = "bliss" },
		["Wildwood"] = { arid = "wildwood" },
		["Winds of Fate"] = { arid = "winds" },
		["Winterlands"] = { arid = "winter" },
		["Xyl's Mosaic"] = { arid = "xylmos" },
		["Yggdrasil: The World Tree"] = { arid = "ygg" },
		["Zangar's Demonic Grotto"] = { arid = "zangar" },
	}	
		-------- AREA LEVEL INDEX FUNCTIONS -------
	function area_index_start()		-- called by trigger for "Showing areas from 0 to 300" line at start of areas list.
		area_range = {}
		ColourNote("#FF5000", "", "*** Indexing area levels... - new version")
	end
	function area_index_line(name, line, wildcards)			-- called by trigger reacting to the output lines from the areas list.
		local areaName = Trim(wildcards.areaName)
		local arid = Trim(wildcards.arid)
		local minLvl = tonumber(Trim(wildcards.min)) or 1
		local maxLvl = tonumber(Trim(wildcards.max)) or 201
		local levelLock = tonumber(Trim(wildcards.lock)) or 0
		if areaDefaultStartRooms[arid] then		     
			if (arid == "sahuagin") then areaName = "The Abyssal Caverns of Sahuagin"
			elseif (arid == "darkside") then areaName = "The Darkside of the Fractured Lands"
			end
			if (areaDefaultStartRooms[arid].noquest == true) then
				-- do nothing, we don't want to add noquest areas to the index
			else
				area_range[areaName] = { arid = arid, min = minLvl, max = maxLvl, lock = levelLock }
			end
		else
			ColourNote("#802800", "", "*** Missing default start room - " .. areaName)
		end
	end
	function area_index_end(name, line, wildcards)
		--tprint(area_range)
		Send_GMCP_Packet("request room")
		ColourNote("#FF5000", "", "\n*** Area levels indexed!")
		Execute("cp info")
		DoAfterSpecial(0.5, "xset resume page size", sendto.execute)
		
	end
	
	function option_set_xcp_mode(name, line, wildcards)
			local opt = wildcards.option or ""
			local options = {
				["ht"] = "ht - do hunt trick",
				["qw"] = "qw - do quick where",
				["off"] = "off - no additional action",
				}
			if (opt == "ht") or (opt == "qw") or (opt == "off") then
				CONFIG_xcp_mode = opt
				SetVariable("mcvar_CONFIG_xcp_mode", opt)
				ColourNote("#40C040", "", "Set 'xcp' mode to: " .. options[opt] .. ".")
			elseif (opt == "") then
				ColourNote("#FF5000", "", "Current 'xcp' mode: " .. options[CONFIG_xcp_mode] .. ".")
				ColourNote("#FF5000", "", "Syntax: 'xcp mode [ht|qw|off]'")
			else
				ColourNote("#FF5000", "", "Invalid 'xcp' mode given.  Syntax: 'xcp mode [ht|qw|off]'")
			end
			print("")
	end
	function set_speed(name, line, wildcards)
		if (wildcards.speed ~= "") then
			speed = wildcards.speed
		else
			if (speed == "walk") then
				speed = "run"
			else
				speed = "walk"
			end
		end
		ColourNote("#FF5000", "", "Move speed:" .. speed)
	end
	function move_trigger(name, line, wildcards)
		if (wildcards.roomid == "-1") then
			ColourNote("#FF5000", "", "\nSearch and Destroy:  Can't go to room id -1 (nomap room)\n")
		elseif (wildcards.roomid ~= "") then
			move(wildcards.roomid, wildcards.speed)
		end	
	end
	function move(rmid, temp_speed)
		if (temp_speed == nil or temp_speed == "") then
			temp_speed = speed
		end
		if (temp_speed == "walk") then
			Note("walking to " .. rmid)
			Execute("mapper walkto " .. rmid)
		else
			Execute("mapper goto " .. rmid)
		end
	end
	function cp_mob_killed()
		xcp_retry_stat = 1
		xcp_index = 0
		gotoIndex = 0
		gotoList = {}
		Execute("cp ch")
	end
	function cp_check_start(name, line, wildcards)
		local time_check = os.clock()					-- prevent double cp checks from different plugins
		if ((time_check - last_cp_check) < 1.0) then
			return
		end
		last_cp_check = time_check
		cp_check_list = {}
		cp_check_index = 1
		Send("cp ch")
	end
	
	function cp_check_line(name, line, wildcards)
		local mob = wildcards.mob
		local loc = wildcards.loc
		local is_dead = (wildcards.isdead == "" and "no" or "yes")
		cp_check_list[cp_check_index] =  { mob = mob, loc = loc, is_dead = is_dead, ord = cp_check_index}
		cp_check_index = cp_check_index + 1
	end
	function cp_check_end(name, line, wildcards)
		build_cp_target_list(cp_check_list)
		if (xcp_retry_stat == 2) then
			if (xcp_index == 0) or (xcp_index == 1) then
				xcp_retry_stat = 0
				xcp_noarg()
			else
				xcp_retry_stat = 0
				Execute("xcp " .. xcp_index)
			end
		end
		xcp_retry_stat = 0
	end
	local sql_build_area_target =
		--	" SELECT '' as roomid, '' as roomName, uid as arid, name as areaName, 'area' as type, '' as info " ..
			" SELECT uid as arid, name as areaName " ..
			" FROM areas " ..
			" WHERE name = %s " ..
			" ORDER BY arid ASC "
	local sql_build_room_target =
			" SELECT r.uid as roomid, r.name as roomName, a.uid as arid, a.name as areaName, 'room' as type " ..
			" FROM rooms r " ..
			" INNER JOIN areas a ON r.area = a.uid " ..
			" WHERE r.name = %s "
	
	function build_cp_target_list(t)	-- t = cp_check_list
		if cp_type == "area" then	-- branch for area cp
			build_area_cp_target(t)
		elseif cp_type == "room" then	-- branch for room cp
			build_room_cp_target(t)
		elseif cp_type == "none" then	-- should never be called but who knows
			print("cp target builder error - attempt to run while not on campaign")
			return
		end
		print_cp_target_links(cp_target_list)
	end
	
	function build_area_cp_target(t)
		local cp_list = {}
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))
		local row_index = 0
		for i,v in ipairs (t) do
			local row_count = 0
			local select = string.format(sql_build_area_target, fixsql(v.loc))
			for row in db:nrows(select) do
				row_count = 1
				row_index = row_index + 1
				--cp_target_list[row_index] = {
				cp_list[row_index] = {
					mob = v.mob,
					arid = row.arid,
					is_dead = v.is_dead,
					type = "area",
					ord = row_index	}
			end
			if (row_count == 0) then	-- area name wasn't found in mapper db
				row_index = row_index + 1
				cp_list[row_index] = {mob = v.mob, location = v.loc, is_dead = v.is_dead, type = "unknown_area", ord = row_index}
				--cp_target_list[row_index] = {mob = v.mob, location = v.loc, is_dead = v.is_dead, type = "unknown_area", ord = row_index}
			end
		end
		db:close_vm()
		cp_target_list = cp_list
	end
	function build_room_cp_target(t)
		cp_list = {}
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))
		local row_index = 0
		local level_taken = cp_level
		
		for i,v in ipairs (t) do
			local row_count = 0
			local select = string.format(sql_build_room_target, fixsql(v.loc))
			local lastMobSignature = ""
			for row in db:nrows(select) do
					if (area_range[row.areaName] == nil) then	-- noquest areas never contain targets and are excluded from results 
					else
						local min_lvl = (area_range[row.areaName].min) or 1
						local max_lvl = (area_range[row.areaName].max) or 300
						local vmax = ((level_taken >= 100) and 20 or 30)
						local vmin = 0
						row_count = row_count + 1
						local mobSignature = row.areaName .. "|" .. v.mob
						if (lastMobSignature ~= mobSignature) then
							if (level_taken >= (min_lvl + vmin)) and (level_taken <= (max_lvl + vmax)) then	-- filter results outside sensible level range
								row_index = row_index + 1
								cp_list[row_index] = {
									mob = v.mob,
									roomid = row.roomid,
									arid = row.arid,
									roomName = row.roomName,
									is_dead = v.is_dead,
									minlvl = min_lvl,
									maxlvl = max_lvl,
									--info = row.info,
									type = ((v.is_dead == "no") and "room" or "area"),	-- deals with dead mobs when area contains roomnames same as area name e.g. Aardington Estate
									ord = row_index	}
							else	-- area containing roomname is outside level ranges
								local link = string.format("Ignoring due to level : %s in '%s' (%s) [%s-%s]", v.mob, row.roomName, row.arid, min_lvl, max_lvl)
								Hyperlink("xm move " .. row.roomid, link, "Move to room " .. row.roomid, "Khaki", "", 0)
								print("")
							end
						end
						lastMobSignature = mobSignature
					end
			end
			if (row_count == 0) then
				if (v.is_dead == "yes") then	-- mob is dead
					local select = string.format(sql_build_area_target, fixsql(v.loc))
					for row in db:nrows(select) do	-- mob is dead but the location is known
						row_index = row_index + 1
						cp_list[row_index] = {mob = v.mob, arid = row.arid, is_dead = "yes", type = "area", ord = row_index}
					end
					if row_count == 0 then	-- mob is dead and the location is unknown
						row_index = row_index + 1
						cp_list[row_index] = {mob = v.mob, location = v.loc, is_dead = "yes", type = "unknown_area", ord = row_index}
					end
				else	-- mob is alive, but no location is known
					row_index = row_index + 1
					cp_list[row_index] = {mob = v.mob, location = v.loc, is_dead = v.is_dead, type = "unknown_room", ord = row_index}
				end
			end
		end
		db:close_vm()
		cp_target_list = cp_list
	end
	
	function print_cp_target_links(list)		-- show the list of target links from cp check (not the same as 'go' links)
		lastMobSignature = ""	--reset signature for next search
		if (CONFIG_show_help == "true") then
			ColourNote("Gray", "", "\n------------------------------------------------------------------------------------------")
		end
		local index = 0
		for i,v in ipairs (list) do
			index = index + 1
			local mobText = v.mob
			local deadFlag
			local is_dead = v.is_dead
			local link
			local linkhelp
			local notehelp = "Show notes for item " .. i
			local color
			if (is_dead == "yes") then
				mobText = mobText .. " [Dead]"
				deadFlag = true
			end
			
			if (v.type == "area") then
				link = string.format(" %2d  %s - %s", padRight(i, 6, " "), padRight(mobText, 30, " "), padRight(v.arid, 10, " "))
				linkhelp = "Target cp mob " .. i .. " - " .. mobText .. " (" .. v.arid .. ")"
				color = ((is_dead == "yes") and "#404040" or "#E0E0E0")	-- dark grey, very light grey
				Hyperlink("xcp " .. i, link, linkhelp, color, "", 0)
				Hyperlink("roomnote area " .. v.arid, "  [notes]", notehelp, ((is_dead == "yes") and "#383838" or "lightgreen"), "", 0)
			elseif (v.type == "room") then
				local roomText = "'" .. v.roomName .. "' (" .. v.roomid .. ")"
				link = string.format(" %2d  %s - %s %s [%d+]", padRight(i, 4, " "), padRight(mobText, 30, " "), padRight(v.arid, 10, " "), padRight(roomText, 40, " "), v.minlvl)
				linkhelp = "Target cp mob " .. i .. " - " .. mobText .. " (" .. v.arid .. ")"
				color = ((is_dead == "yes") and "#404040" or "#E0E0E0")	-- dark grey, very light grey
				Hyperlink("xcp " .. i, link, linkhelp, color, "", 0)
			elseif (v.type == "unknown_area") then
				link = string.format(" %2d  %s - area '%s' not in mapper db", padRight(i, 4, " "), padRight(mobText, 30, " "), v.location)
				linkhelp = "Area not found in mapper database"
				color = ((is_dead == "yes") and "#900000" or "#FF0000")	-- dark red, bright red
				Hyperlink(" ", link, linkhelp, color, "", 0)
			elseif (v.type == "unknown_room") then
				link = string.format(" %2d  %s - room '%s' not in mapper db", padRight(i, 4, " "), padRight(mobText, 30, " "), v.location)
				linkhelp = "Room not found in mapper database"
				color = ((is_dead == "yes") and "#900000" or "#FF0000")	-- dark red, bright red
				Hyperlink(" ", link, linkhelp, color, "", 0)
			end		
			print("")
		end
		if (index == 0) then
			ColourNote("#FF5000", "", "   No campaign items to show.  (If this appears to be a bug, do 'areas 1 300 keywords')")
		end
		if (CONFIG_show_help == "true") then
			ColourNote("Gray", "", "------------------------------------------------------------------------------------------")
			ColourNote("Gray", "", "Type 'xcp <index>' or click link to go to that target.")
		end
		xgui_RefreshWindow()
	end
	
	function goto_number(name, line, wildcards)		-- called by "go" / "goto" command
		gotoIndex = tonumber(wildcards.id) or 1
		if (gotoList[gotoIndex] ~= nil) then
			if (tonumber(gotoList[gotoIndex]) == nil) then
				Execute("xrt " .. gotoList[gotoIndex])
				Execute("qs")
			else
				next_room = gotoList[gotoIndex]
				goto_room(gotoList[gotoIndex])
				Execute("qs")
			end
		else
			ColourNote("#FF5000", "", "Goto next (go) aborted - No destination yet.")
		end
	end
	function goto_next(name, line, wildcards)		-- called by "nx" command
		if (next_room == nil) or (next_room == "") or (next_room == -1) then
			ColourNote("#FF5000", "", "Goto next (nx) aborted - No data yet.")
			return
		end
		if (tonumber(next_room) == tonumber(currentRoom.rmid)) and (gotoIndex < #gotoList) then
			gotoIndex = gotoIndex + 1
		end
		if gotoList[gotoIndex] then
			ColourNote("#40C040", "", "Next room (nx) - " .. gotoIndex .. " of " .. #gotoList)
			next_room = gotoList[gotoIndex]
			Execute("xmapper move " .. next_room)
			Execute("qs")
		else
			ColourNote("#FF5000", "", "Goto next (nx) aborted - No more rooms.")
		end
	end	
	function goto_previous(name, line, wildcards)	-- called by "nx-" command
		if (next_room == nil) or (next_room == "") or (not tonumber(next_room)) then
			ColourNote("#FF5000", "", "Goto previous (nx-) aborted - No data yet.")
			return
		end
		if (tonumber(next_room) == tonumber(currentRoom.rmid)) and (gotoIndex > 1) then
			gotoIndex = gotoIndex - 1
		end
		if gotoList[gotoIndex] then
			ColourNote("#40C040", "", "Previous room (nx-) - " .. gotoIndex .. " of " .. #gotoList)
			next_room = gotoList[gotoIndex]
			Execute("xmapper move " .. next_room)
			Execute("qs")
		else
			ColourNote("#FF5000", "", "Goto previous (nx-) aborted - No more rooms.")
		end
	end	
	
	function goto_room(rmid)
		local dest_in_vidblain = is_vidblain_area(rmid)
		local both_in_vidblain = dest_in_vidblain and is_vidblain_area(currentRoom.rmid)
		if (dest_in_vidblain == true) and (is_vidblain_area(currentRoom.rmid) == false) then
			Execute("mapper goto 11910")
			Execute("enter hole")
			local func = function() Execute("xmapper move " .. rmid .. " walk") end
			execute_in_area("vidblain_hack", "vidblain", func)
		elseif (dest_in_vidblain == true) and (is_vidblain_area(currentRoom.rmid) == true) then
			Execute("xmapper move " .. rmid .. " walk")
		else
			Execute("xmapper move " .. rmid)
		end
	end
	
	function xcp_noarg()	-- xcp with no argument given, so find the first available mob (alive, location known) and go to it.
		local index = 1
		local cp_list = cp_target_list
		if (cp_type == "none") then	-- abort if not on cp
			ColourNote("#FF8800", "", "\nSearch and Destroy: 'xcp' aborted - you're not on a cp.\n")
			return
		elseif (#cp_list == 0) then	-- abort if on a cp, but target list is empty
			ColourNote("#FF8800", "", "\nSearch and Destroy: 'xcp' aborted - cp is active but target list is empty.\n")
			return
		else
			for i,v in ipairs (cp_list) do	-- loop through list and try to find something to kill.
				if v.is_dead == "no" and (v.type == "area" or v.type == "room") then	-- if mob is alive and location known, go to it.
					--index = index + 1
					break
				else
					index = index + 1
					if (i > #cp_list) then 	-- if we reach this step, all mobs are dead and/or location wasn't known.  Take a break and wait for something to repop.
						ColourNote("#FF8800", "", "\nSearch and Destroy: 'xcp' aborted - lack of targets (dead, or location unknown)")
						return
					end
				end
			end
		end
		xcp_index = index
		xcp_goto_target(index)
	end
	
	function xcp_arg(name, line, wildcards)
		local index = tonumber(wildcards.index)
		local cp_list = cp_target_list
		if (cp_type == "none") then	-- abort if not on cp
			ColourNote("#FF8800", "", "\nSearch and Destroy: 'xcp' aborted - you're not on a cp.\n")
			return
		elseif (#cp_list == 0) then	-- abort if on a cp, but target list is empty
			ColourNote("#FF8800", "", "\nSearch and Destroy: 'xcp' aborted - cp is active but target list is empty.\n")
			return
		elseif (index > #cp_list) or (index < 0) then	-- abort if index doesn't exist
			ColourNote("#FF8800", "", "\nSearch and Destroy: 'xcp' aborted - index doesn't exist (".. index .. ")\n")
			return
		elseif (index == 0) then	-- clear xcp target
			xcp_index = 0
			gotoIndex = 0
			gotoList = {}
			xgui_RefreshWindow()
			ColourNote("#FF8800", "", "\nSearch and Destroy: 'xcp' current target cleared.\n")
			return
		elseif (cp_list[index].type == "unknown_area") or (cp_list[index].type == "unknown_room") then	-- abort if unknown
			ColourNote("#FF8800", "", "\nSearch and Destroy: 'xcp' aborted - no mapper data for target (#" .. index .. ").\n")
			return
		else	-- everything is in order, so go to mob.
			--print("xcp_arg: " .. index)
			xcp_index = index
			xcp_goto_target(index)
		end
	end
	
	function xcp_goto_target(index)
		if (xcp_retry_stat == 2) then
			return
		elseif (xcp_retry_stat == 1) then
			xcp_retry_stat = 2
			return
		end
		local cpmob = cp_target_list[index]
		local room = gmcp("room.info.num") --currentRoom.rmid
		local arid = gmcp("room.info.zone") --currentRoom.arid
		local mode = CONFIG_xcp_mode
		gotoList = {}
		gotoIndex = 1
		if (cpmob ~= nil) and (room ~= nil) and (arid ~= nil) then
			guess_mob_keywords(cpmob.mob)
			if (cpmob.type == "area") then	-- Area cp links - "xcp" goes to target area, then runs Hunt Trick to get target room.
				if (arid ~= cpmob.arid) then	-- if you're not in target area, xrunto target area.
					Execute("xrt " .. cpmob.arid)
				end
				if (mode == "ht") then		-- do automatic hunt trick after arriving in area.
					local func = function() Execute("x_ht " .. cpmob.mob) end
					execute_in_area("goto_list_item_area", cpmob.arid, func)
				elseif (mode == "qw") then	-- do automatic quick where.
					local func = function() Execute("x_qw " .. cpmob.mob) end
					execute_in_area("goto_list_item_area", cpmob.arid, func)
				elseif (mode == "off") then	-- do nothing
					ColourNote("#FF5000", "", "Xcp mode is off - no additional action")
					print("")
				end
			else	-- Room cp:  get target room from mapper, but don't move yet.  "go" takes you to room.
				search_rooms(cpmob.roomName .. "|" .. cpmob.arid, "area", cpmob.mob)
			end
		else
			ColourNote("#FF5000", "", "No item exists, or data is busy")
		end
		xgui_RefreshWindow()		-- tells GUI plugin to color the current target
	end
	local xrun_to_sql_uid =  
		"SELECT r.uid, r.name as room, r.area " ..
		"FROM rooms r " ..		
		"WHERE r.area like %s " ..
		"ORDER BY r.name "
	local xrun_to_sql_name =  
		"SELECT r.uid, r.name as room, r.area " ..
		"FROM rooms r " ..
		"INNER JOIN areas a ON a.uid = r.area " ..
		"WHERE r.area like %s OR a.name like %s " ..
		"ORDER BY r.name "
		
	function xrun_to(name, line, wildcards)
		local destination = wildcards.loc
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))		-- finds your mapper database
		--local db = assert(sqlite3.open(worldPath .. ".db"))		-- opens your mapper db
		if (destination == "ft2") then destination = "ftii" end	-- HACK for ftii (allows one to 'xrt ft2' as well as 'xrt ftii')
		local startRoom = get_start_room(destination)			-- Check for xset marked room
		if (startRoom == "-1") then		-- area has no start room defined.
			ColourNote("#FF5000", "", "X-runto: There is no default start room defined for area '" .. destination .. "'.\n")
			SendNoEcho("areas 1 299 keywords " .. destination)
		else	-- start room is either 'xset marked' or has a preset default, so we'll go there.
			ColourNote("#FF5000", "", "X-runto: " .. destination .. ", room ID: " .. startRoom .. " (" .. start_room_type .. ")\n")
			goto_room(startRoom)
		end			
	end
	function xset_pk(name, line, wildcards)
	--	if (showPK == "true") then
	--		showPK = "false"
	--	else
	--		showPK = "true"
	--	end
	--	SetVariable("showPK", showPK)
	--	ColourNote("#FF5000", "", "Show PK room flag : " .. showPK)
	end
	function xset_to_mark(name, line, wildcards)
		areaStartRooms[currentRoom.arid] = { areaname = "temp", roomid = currentRoom.rmid }
		ColourNote("#FF5000", "", "\n" .. currentRoom.rmid .. " set as starting room for " .. currentRoom.arid .. "\n")
		SetVariable("areaStartRooms", serialize.save_simple(areaStartRooms))
		tprint(areaStartRooms)
	end
	
	function get_start_room(area_id)
		local arid = string.lower(area_id)		
		start_room_type = "xset mark"					-- If 'xset mark' was set, xrunto will go there.
		if (areaStartRooms[arid] ~= nil) then 			-- Function exits as soon as any 'return' statement is encountered.
			return areaStartRooms[arid].roomid			-- Exact match on area id
		end
		for k,v in pairs (areaStartRooms) do			
			if (string.match(string.lower(k), arid) ~= nil) then 				
				return v.roomid	-- string match on key
			end
		end
		start_room_type = "default"						-- If 'xset mark' isn't set, look up start room from the table areaDefaultStartRooms.
		if (areaDefaultStartRooms[arid] ~= nil) then 	-- Note, Upper/Lower Planes have the same default room.  More development needed here.	
			return areaDefaultStartRooms[arid].roomid	-- exact match on area id
		end
		for k,v in pairs (areaDefaultStartRooms) do
			if (string.match(string.lower(k), arid) ~= nil) then 				
				return v.roomid	-- string match on key
			end
		end		
		return "-1"
	end															
	---- room notes --------
	function room_note_area(name, line, wildcards)
		if (wildcards.arid == "") then
			get_notes(currentRoom.arid, nil)
		else
			get_notes(wildcards.arid, nil)
		end
	end
	function room_note(name, line, wildcards)
		get_notes(nil, currentRoom.rmid)
	end
	function get_notes(arid, roomid, text_only)
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))
		local sql =  " SELECT b.uid, b.notes "
		sql = sql .. " FROM bookmarks b "
		if (arid ~= nil) then
			sql = sql .. " INNER JOIN rooms r ON b.uid = r.uid "
			sql = sql .. " WHERE r.area = " .. fixsql(arid)
		else
			sql = sql .. " WHERE b.uid = " .. fixsql(roomid)
		end
		sql = sql .. " ORDER BY b.uid "
		--print(sql)	-- to see what sql statement is being executed if needs be
		local index = 0
		if (arid ~= nil) then
			Simulate("\nNotes for " .. getAreaName(arid) .. "\n")
		end
		for row in db:nrows(sql) do
			index = index + 1
			if (text_only == true) then
				local line = string.format("    note:'%s'", row.notes)
				Hyperlink("xmapper move " .. row.uid, line, "go to room " .. row.uid, "lightblue", "black", 0)		
			else
				local line = string.format("    (%s) %s", row.uid, row.notes)
				Hyperlink("xmapper move " .. row.uid, line, "go to room " .. row.uid, "lightblue", "black", 0)
				print("")
			end		
		end
		db:close_vm()
		if (arid ~= nil and index == 0 and text_only ~= true) then
			Simulate("\tNo notes.\n")
		end
	end
	function getAreaId(name)
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))
		local sql =  "SELECT uid FROM areas WHERE name = %s"
		for row in db:nrows(string.format (sql, fixsql(name))) do
			db:close_vm()
			return row.uid
		end
		db:close_vm()
		return name
	end
	
	function getAreaName(uid)
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))
		local sql =  "SELECT name FROM areas WHERE uid = %s"
		for row in db:nrows(string.format (sql, fixsql(uid))) do
			db:close_vm()
			return row.name
		end
		db:close_vm()
		return uid
	end
	function getAreaUid(name)
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))
		local sql =  "SELECT uid FROM areas WHERE name = %s order by uid "
		local areas = {}
		local index = 0
		for row in db:nrows(string.format (sql, fixsql(name))) do
			index = index + 1
			areas[index] = {uid = row.uid, name = name}
		end
		db:close_vm()
		return areas
	end
	function map_area(name, line, wildcards)
		search_rooms(wildcards.loc, 'area', wildcards.mob)
	end
	function map_area_all(name, line, wildcards)
		search_rooms(wildcards.loc .. "|all", 'all', wildcards.mob)
	end
	
	local search_rooms_sql = 
		"SELECT r.uid as uid, r.name as name, info, r.area as area, " ..
		"ifnull(a.name, r.area) as area_name, 1 as DisplayOrder " .. 
		"FROM rooms r " ..
		"LEFT OUTER JOIN areas a ON r.area = a.uid " ..
		"WHERE r.name = %s " ..
		"AND (%s = 'all' OR (a.name = %s OR r.area = %s)) " ..
		"UNION " ..
		"SELECT r.uid, r.name, info, r.area, " ..
		"ifnull(a.name, r.area) as area_name, 0 as DisplayOrder " .. 
		"FROM rooms r " ..
		"LEFT OUTER JOIN areas a ON r.area = a.uid " ..
		"WHERE r.name <> %s " ..
		"AND r.name LIKE %s " .. 
		"AND (%s = 'all' OR (a.name = %s OR r.area = %s)) " ..
		"ORDER BY Area, DisplayOrder DESC "
	
	function search_rooms(room, searchType, fullMobName)
		if (room == nil or room == "") then
			Note("map_area() error : room is not known")
			return
		end
		-- room|area
		local parts = split(room, "[^|]+") -- pipe delimited
		local room = parts[1]
		local area_id
		if (#parts == 2) then
			area_id = parts[2]
		else
			if (currentRoom ~= nil) then
				area_id = currentRoom.arid
			else
				ColourNote("#FF5000", "", "Area not known, falling back to mapper list")
				Execute("mapper list " .. parts[1])
			end
		end
		if (room == nil) then
			Note("map_area() - Room not known")
			return
		end
		like = "%"..room.."%"
		-- i forget what this does? Strip out a leading " ?
		--if string.sub(room,1,1) == "\"" and string.sub(room,-1) == "\"" then
		--	like = string.sub(room,2,-2)
		--end
		local select = string.format(search_rooms_sql, 
			fixsql(room), 
			fixsql(area_id), 
			fixsql(area_id), 
			fixsql(area_id), 
			fixsql(room), 
			fixsql(like), 
			fixsql(area_id), 
			fixsql(area_id), 
			fixsql(area_id))
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))
		local results = {}
		local roomid_list = {}
		for row in db:nrows(select) do
			local id = (tonumber(row.uid) or -1)	-- sanitize text room ids for "unmappable" rooms that are now being mapped
			results[#results + 1] = { 
				rmid = id, 
				name = row.name,
				info = row.info,
				area = row.area_name,
				arid = row.area or row.area_name -- make safe against bad dbs			
			}
			if (id > 0) then	-- make a list of room ids
				roomid_list[#roomid_list + 1] = id
			end
		end   -- finding rooms
		db:close_vm()
		search_rooms_results(results)
	end
	function search_rooms_results(results)	-- Display list of 'go' links from hunt-trick, quick-where, etc.
		gotoList = {}
		mapper_area_index = 0
		local last_area = ""
		if (CONFIG_show_help == "true") then
			ColourNote("Gray", "", "\nIndex    Location     (uid)")
			ColourNote("Gray", "", "------------------------------------------------------------")
		end
		for i,v in ipairs (results) do
			if (last_area ~= v.arid) then
				if (mapper_area_index == 0) then
					local areaLine = string.format("~~~ %2d   %s", mapper_area_index, v.arid)
					Hyperlink("go " .. mapper_area_index, areaLine, "go to area " .. v.arid, "silver", "", 0)
					gotoList[mapper_area_index] = v.arid
					mapper_area_index = mapper_area_index + 1
				else
					local areaLine = string.format("~~~   %s", v.arid)
					Hyperlink("xrt " .. v.arid, areaLine, "go to area " .. v.arid, "silver", "", 0)
				end				
				print("")
				last_area = v.arid				
			end
			
			local line1 = string.format("~~~ %2d   ", mapper_area_index)
			Hyperlink("go " .. mapper_area_index, line1, "go to item " .. mapper_area_index, "lightblue", "", 0)
			
			local line2 = string.format("%s  (%s) ", padRight(string.gsub(v.name, "@[a-zA-Z]", ""), 20, " "), v.rmid)
			Hyperlink("go " .. mapper_area_index, line2, "go to item " .. mapper_area_index, "lightblue", "", 0)
			Hyperlink("mapper where " .. v.rmid, "   {?}", "click for speedwalk to this room", "LightSteelBlue ", "", 0)
			gotoList[mapper_area_index] = v.rmid
			print("")
			mapper_area_index = mapper_area_index + 1
		end
		if (mapper_area_index == 0) then ColourNote("#FF5000", "", "No matching rooms found.") end
		if (CONFIG_show_help == "true") then
			ColourNote("Gray", "", "------------------------------------------------------------")
			ColourNote("Gray", "", "Type 'go <index>' or click link to go to that room.")
		end
		
	end
	local cp_simulate_toggle = "0"
	function cp_simulate(name, line, wildcards)
		local time_check = os.clock()					-- prevent double cp checks from different plugins
		if ((time_check - last_cp_check) < 1.0) then
			return
		end
		last_cp_check = time_check
		cp_check_list = {}
		cp_check_index = 1
		EnableTrigger("trg_cp_check_line", true)
		Simulate("\n")	
		--if (cp_simulate_toggle == "0") then
			Simulate("You still have to kill * A test mob (A Cold Path)\n")	--dead
			Simulate("You still have to kill * Isscheburqua (Insanitaria)\n")
			Simulate("You still have to kill * a rook citizen (Avian Kingdom)\n")
			Simulate("You still have to kill * Lea, the farmer's daughter (Farmyard)\n")
			Simulate("You still have to kill * a rook citizen (Nesting Home)\n")
			Simulate("You still have to kill * a demon school student (The School of Horror)\n")
			Simulate("You still have to kill * a hookle fish (Black Lagoon)\n")
			Simulate("You still have to kill * Harry (Unknown Tower)\n")		--dead
			Simulate("You still have to kill * a former court jester (The Labyrinth)\n")
			Simulate("You still have to kill * Parent (A Cold Path - Dead)\n")
			Simulate("You still have to kill * a wealth redistribution specialist (Empyrean, Streets of Downfall)\n")
			Simulate("You still have to kill * the reaching thorns (Eternal Autumn)\n")
			Simulate("You still have to kill * Redtooth (Mossflower Wood - Dead)\n")	--dead
			Simulate("You still have to kill * Castle Guard (Rebellion of the Nix)\n")
			Simulate("You still have to kill * Jules (The Amazon Nation)\n")
			Simulate("You still have to kill * an earth fiend (The Broken Halls of Horath)\n")
			Simulate("You still have to kill * the spirit of Bakarne (The Empire of Aiighialla)\n")
			Simulate("You still have to kill * Elfgar Sous-Fled (Some Place)\n")
			Simulate("You still have to kill * the heart of a sandstorm (Living Mines of Dak'Tai)\n")
			cp_simulate_toggle = "1"
		--else
			--Simulate("You still have to kill * a former court jester (The Labyrinth)\n")
			--Simulate("You still have to kill * the heart of a sandstorm (Buried in the Great Desert's unrelenting dunes)\n")
			--Simulate("You still have to kill * Parent (The Kitchen)\n")
			--Simulate("You still have to kill * a rhino seraph (A Corridor of Cinnamon and Silver)\n")
			--Simulate("You still have to kill * A sprite prisoner (A cell)\n")
		
		--	cp_simulate_toggle = "0"
		--end
		Simulate("Note: Dead means that the target is dead, not that you have killed it.\n")
		Simulate("\n")
		Simulate("You have 6 days, 23 hours and 56 minutes left to finish this campaign.\n")
		Simulate("\n")
		
	end
	------ Execute in Area ------
	function execute_in_area(id, targ_arid, functionPointer)		-- see example of how to use in function goto_room
		execute_in_area_array[id] = { arid = targ_arid, func = functionPointer, index = 0, active = true, lastState = "3", standIndex = 0 }	--lastState = 3 = standing
		--tprint(execute_in_area_array)																										--standIndex = # of stands in a row (?)
		EnableTimer("execute_in_area_timer", true)
	end
	function execute_in_area_tick(name, line, wildcards)
		--print(curr_room_arid)
		local localRoom = currentRoom
		local localState = char_state or "1"
		if (localRoom == nil) then		-- thread safety
			return
		end
		local isActive = false
		for k, v in pairs(execute_in_area_array) do
			if (v.active == true) then
				v.index = v.index + 1
				if (v.index > 100) then
					v.active = false
					print("** aborting quickwhere timer for " .. k .. ", took too long to get to destination")
				else
					if ((localState == "3" and v.lastState == "3") and v.arid == localRoom.arid) then
						v.index = v.index + 1	-- skip first timer tick
						v.standIndex = v.standIndex + 1
						if (v.standIndex < 2) then
						else
							v.func()
							v.active = false						
						end
					else	-- still moving.. reset index
						v.standIndex = 0
					end
				end
			end
			v.lastState = localState
			if (v.active == true) then
				isActive = true
			end
		end
		if (isActive == false) then		-- no timer items active.. disable
			EnableTimer("execute_in_area_timer", false)
		end
	end
	function xset_vidblain_onoff(name, line, wildcards)
		local x = CONFIG_xset_vidblain
		x = (x == "on") and "off" or "on"
		CONFIG_xset_vidblain = x
		SetVariable("mcvar_xset_vidblain_onoff", x)
		ColourTell ("#FF5000", "", "\nNo-portal vidblain assistance: ",
					"#40C040", "", x)
		print("\n")
	end
	local xset_vidblain_level = tonumber(GetVariable("mcvar_xset_vidblain_level")) or 300
	function xset_vidblain_setlevel(name, line, wildcards)
		local x = tonumber(wildcards.level)
		xset_vidblain_level = x
		SetVariable("mcvar_xset_vidblainlevel", x)
		ColourTell ("#FF5000", "", "\n'xset vidblain' cutoff set to level ", 
					"#40C040", "", x)
		print("\n")
	end
	local is_vidblain_area_sql = "SELECT area " .. "FROM rooms " .. "WHERE uid = %s "
	function is_vidblain_area(roomid)
		if (CONFIG_xset_vidblain == "off") then	return false end
		local level = tonumber(gmcp("char.status.level")) + 10 * tonumber(gmcp("char.base.tier"))
		if (level >= xset_vidblain_level) then return false	end
		
		local worldPath = GetInfo(66) .. Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))
		local select = string.format (is_vidblain_area_sql, fixsql(roomid))
		for row in db:nrows(select) do
			local a = row.area
			if (a == "darklight" or a == "imperial" or a == "omentor" or a == "sendhian" or a == "vidblain") then
				db:close_vm()
				return true
			end
		end		
		db:close_vm()
		return false
	end
	--------- Sql Execution ------------
	function RunSql(name, line, wildcards)
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))
		local index = 0
		local sql = wildcards.sql
		ColourNote("#FF5000", "", "running :" .. sql)
		for row in db:nrows(sql) do
			index = index + 1
			print("----------- record " .. index .. " -----------" )
			tprint(row)
	--		print (serialize.save ("row", row))
		end
		db:close_vm()
	end
	function ExecSql (name, line, wildcards)
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))
		Note("executing " .. wildcards.sql)
	--	dbcheck (db:execute (fixsql(wildcards.sql)))
		db:execute(fixsql(wildcards.sql))
		db:close_vm()
		Note("ok")
	end
-- *** former plugin - Search and Destroy ** --
-- ********** QUEST INFO PROCESSING **********	
	function xquest_1()
		Send_GMCP_Packet("request quest")
	end
	
-- ********** CAMPAIGN INFO PROCESSING **********
	function cp_info_start()
		currentRoom = gmcp("room.info")
		cp_info_targets = {}
		cp_info_index = 1
		Send("cp info")
	end
	
	function cp_level_taken(name, line, wildcards)
		cp_level = tonumber(wildcards.level)
		SetVariable("mcvar_cp_level", cp_level)
		--print(cp_level)
	end
	
	function cp_info_line(name, line, wildcards)
		local mobname = wildcards.mob
		local location = wildcards.loc
		local keyword = guess_mob_keywords(mobname, false)
		cp_info_targets[cp_info_index] = { mob = mobname, loc = location, kw = keyword, ord = cp_info_index}
		cp_info_index = cp_info_index + 1
	end
	
	function cp_info_end()
		cp_info_type_check()
		if cp_type == "area" then
			--for i,v in ipairs (cp_info_targets) do
			--	print(sd_area_data[v.loc].arid .. " " .. cp_level)
			--end
		end
		DoAfterSpecial(0.2, "cp ch", sendto.execute)
	end
	function cp_info_type_check()
		local list_items = #cp_info_targets
		local areaCount = 0
		local roomCount = 0
		for i,v in ipairs (cp_info_targets) do
			if sd_area_data[v.loc] then
				areaCount = areaCount + 1
			else
				roomCount = roomCount + 1
			end
		end
		if areaCount >= roomCount then
			cp_type = "area"
		else
			cp_type = "room"
		end
		SetVariable("mcvar_cp_type", cp_type)
		print("sd cp type: " .. cp_type .. " (" .. cp_level .. ")\n")
		return cp_type
	end
	
-- ********** xwhere - locate multiple mobs at once **********
	function do_xwhere(name, line, wildcards)
		local n1 = tonumber(wildcards.n1) or ""
		local n2 = tonumber(wildcards.n2) or ""
		local mob = wildcards.mob or ""
		if (n1 == "") or (mob == "") then						-- user entered no numbers, no mobname, or no args at all
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'xwhere' required parameter missing.")
			ColourNote("#FF5000", "", "            Syntax: 'xwhere <n1> <mobname>' or 'xwhere <n1> <n2> <mobname>'\n")
			return
		elseif (n1 ~= "") and (mob ~= "") and (n2 == "") then	-- user entered one number (n1) and a mobname, but no second number (n2)
			ColourNote("#40C040", "", "\nSearch and Destroy: 'xwhere" .. " " .. n1 .. " " .. mob .. "'")
			for i = 1, n1, 1 do
				if (i == 1) then
					Send("where " .. mob)
				else
					Send("where " .. i .. "." .. mob)
				end
			end
		elseif (n1 ~= "") and (mob ~= "") and (n2 ~= "") then	-- user entered n1, n2, and mobname
			ColourNote("#40C040", "", "Search and Destroy: 'xwhere" .. " " .. n1 .. " " .. n2 .. " " .. mob .. "'")
			for i = n1, n2, 1 do
				if (i == 1) then
					Send("where " .. mob)
				else
					Send("where " .. i .. "." .. mob)
				end
			end
		else
			ColourNote("#FF1000", "", "Search and Destroy: 'xwhere' data entry problem!")
		end
	end
--	********** Auto noexp functions **********
	function xset_noexp_tnl(name, line, wildcards)		-- called by alias: "xset noexp" when argument given
		if (wildcards.arg == "") then
			if (auto_noexp_tnl == 0) then
				ColourNote("#FF5000", "", "Search and Destroy: Auto 'noexp' is currently OFF.")
			else
				ColourNote("#FF5000", "", "Search and Destroy: Auto 'noexp' is ON and set to " .. auto_noexp_tnl .. " TNL.\n")
			end
		elseif (wildcards.arg == "off") or (wildcards.arg == "0") then	-- "xset noexp off" and "xset noexp 0" turn auto-noexp off.
			EnableTrigger("trg_cp_check_noexp", false)
			EnableTrigger("trg_mobkill_awards_xp", false)
			auto_noexp_tnl = 0
			SetVariable("mcvar_auto_noexp_tnl", auto_noexp_tnl)
			ColourNote("#FF5000", "", "\nSearch and Destroy: Auto 'noexp' is now OFF.\n")
		else											-- xset with any other (positive) number turns auto-noexp on.
			EnableTrigger("trg_cp_check_noexp", true)
			EnableTrigger("trg_mobkill_awards_xp", true)
			auto_noexp_tnl = tonumber(wildcards.arg)
			SetVariable("mcvar_auto_noexp_tnl", auto_noexp_tnl)
			ColourNote("#FF5000", "", "\nSearch and Destroy: Auto 'noexp' now set to " .. auto_noexp_tnl .. " TNL.\n")
		end
	end
	function set_noexp(on_off)
		if (on_off == "on") or (on_off == "off") then
			noexp_onoff = on_off
			Send_GMCP_Packet("config noexp " .. on_off)
		end
		print("noexp onoff: " .. noexp_onoff)
	end
	
	function cp_check_noexp()		-- called by line 'You may take campaign this level.' in 'cp check'
		new_cp_current_level = "yes"
		if (auto_noexp_tnl > 0) then	-- if auto_noexp_tnl is greater than zero, then auto-noexp is on.
			local tnl = tonumber(gmcp("char.status.tnl"))
			if (tnl < auto_noexp_tnl) and (noexp_onoff == "off") then		-- tnl less than set point and noexp is off --> turn that shit on
				set_noexp("on")
				ColourNote("#FF5000", "", "\nSearch and Destroy: Turning 'noexp' ON (Your TNL is less than " .. auto_noexp_tnl .. ")")
			elseif (tnl > auto_noexp_tnl) and (noexp_onoff == "on") then	-- if over min TNL and noexp is on --> turn noexp off regardless
				set_noexp("off")
				ColourNote("#FF5000", "", "\nSearch and Destroy: Turning 'noexp' OFF (your TNL is greater than " .. auto_noexp_tnl .. ")")
			end
		else 	-- feature is turned off, just show reminder
			auto_noexp_tnl = 0
			ColourNote("#FF5000", "#000000", "Automatic 'noexp' is currently turned OFF.\n")
		end
	end
	
	function mobkill_awards_xp(name, line, wildcards)	-- called when mob kill awards xp
		if (auto_noexp_tnl > 0) then
			DoAfterSpecial(0.2, "check_current_tnl()", 12)
		end
	end
	function check_current_tnl(name, line, wildcards)	-- called via timer set by function mobkill_awards_xp
		local tnl = tonumber(gmcp("char.status.tnl"))
		--print("check current tnl: " .. tnl .. "   new cp this level: " .. new_cp_current_level)
		if (new_cp_current_level == "yes") then
			if (tnl < auto_noexp_tnl) then
				if (noexp_onoff == "off") then
					set_noexp("on")
					ColourNote("#FF5000", "#000000", "Search and Destroy: Turning 'noexp' ON (your TNL is less than " .. auto_noexp_tnl .. ")")
				end
			else
				if (noexp_onoff == "on") then
					set_noexp("off")
					ColourNote("#FF5000", "#000000", "Search and Destroy: Turning 'noexp' OFF (your TNL is greater than " .. auto_noexp_tnl .. ")")
				end
			end
		else
			if (noexp_onoff == "on") then
				set_noexp("off")
				ColourNote("#FF5000", "#000000", "Search and Destroy: Turning 'noexp' OFF (you must level before taking a new campaign)")
			end
		end
	end
	
	function noexp_raise_level()	-- called when player raises a level
		new_cp_current_level = "yes"
	end
	
	function player_start_new_cp()	-- called by line "good luck on your campaign" when starting new cp
		player_on_cp = "yes"
		new_cp_current_level = "no"
		if (noexp_onoff == "on") and (auto_noexp_tnl > 0) then
			ColourNote("#FF5000", "#000000", "Search and Destroy: Turning 'noexp' OFF (you have started a new CP)")
			set_noexp("off")
		end
		--Send_GMCP_Packet("request room")
		Execute("cp info")
		DoAfterSpecial(1.0, "cp ch", sendto.execute)
		xgui_RefreshWindow()
	end
	function new_cp_must_level()	-- called by trigger:  You must level to get a new campaign
		new_cp_current_level = "no"
		if (auto_noexp_tnl > 0) then
			if (noexp_onoff == "on") and (player_on_cp == "yes") then			
				ColourNote("#FF5000", "#000000", "Search and Destroy: Turning noexp OFF (can't take new CP at current level)")
				set_noexp("off")
			end
		end
		xgui_RefreshWindow()
	end
	
	function player_is_on_cp()
		player_on_cp = "yes"
		xgui_RefreshWindow()
	end
	
	function player_not_on_cp()
		EnableTrigger("trg_cp_info_level_taken", false)
		EnableTrigger("trg_cp_info_targets", false)
		EnableTrigger("trg_cp_check_line", false)
		EnableTrigger("trg_cp_check_end", false)
		EnableTrigger("trg_campaign_type", false)
		EnableTrigger("trg_cp_check_noexp", true)
		cp_type = "none"
		cp_level = "***"
		cp_target_list = {}
		cp_check_list = {}
		cp_check_index = 1
		xcp_index = 0
		cp_info_targets = {}
		cp_info_index = 1
		player_on_cp = "no"
		SetVariable("mcvar_cp_type", cp_type)
		SetVariable("mcvar_cp_level", cp_level)
		xgui_ClearWindow()
	end
	
	function noexp_manual_toggle()
		Send_GMCP_Packet("config noexp")
	end
-- end of auto noexp feature
	function xset_quick_kill_command(name, line, wildcards)		-- user-defined attack to use with qk/kk
		if (wildcards.arg == "") then
			ColourNote("#FF5000", "", "Search and Destroy: Quick-kill command currently set to: " .. quick_kill_command)
		else
			quick_kill_command = wildcards.arg
			SetVariable("mcvar_quick_kill_command", quick_kill_command)
			ColourNote("#FF5000", "", "Search and Destroy: Quick-kill command is now set to: " .. quick_kill_command)
		end
	end
	function set_short_mob_name(mobName, callingId)
		if (callingId == nil) then
			callingId = ""
		else
			callingId = callingId .. ":"
		end
		short_mob_name = mobName
	end
	
	function get_short_mob_name()	
		return short_mob_name
	end
	function set_full_mob_name(mobName, callingId)
		if (callingId == nil) then
			callingId = ""
		else
			callingId = callingId .. ":"
		end
		full_mob_name = mobName
	end
	
	function get_full_mob_name()
		return full_mob_name
	end
	
	function set_is_exact(isExact, callingId)
		if (callingId == nil) then
			callingId = ""
		else
			callingId = callingId .. ":"
		end
		is_exact = isExact
	end
	
	function get_is_exact()	
		return is_exact
	end	
	
	function quick_scan(name, line, wildcards)
		if (get_short_mob_name() == nil or get_short_mob_name() == "") then
			Send("scan")
		else
			Send(string.format("scan %s", get_short_mob_name()))
		end
	end
	function quick_kill(name, line, wildcards)
		if (get_short_mob_name() == nil or get_short_mob_name() == "") then
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'Quick-kill' has no target.  Use 'ht', 'qw', or 'xcp' to select a target.\n")
		else
			Execute(quick_kill_command .. " " .. get_short_mob_name())
		end
	end
	local qw = {
			full_name = "",
			short_name = "",
			result_match_name = "",
			exact = 1,
			index = 1
		}
	
	function quick_where_start(name, line, wildcards)
		if (wildcards.mob == "") then
			qw.full_name = get_full_mob_name()
			qw.result_match_name = get_full_mob_name()
			qw.short_name = get_short_mob_name()
			if (qw.full_name == nil or qw.full_name == "") then
				ColourNote("#FF5000", "", "\nSearch and Destroy: 'Quick-where' has no target.  Use 'ht <mob name>', 'qw <mob name>, or 'xcp' to select a target.\n")
				return
			else
				Note("\nSearch and Destroy: Using last quick-where mob...\n")
			end
			qw.exact = get_is_exact()
			qw.index = 1
		else
			qw.full_name = wildcards.mob
			qw.result_match_name = wildcards.mob
			qw.short_name = wildcards.mob
			-- set exact
			if (wildcards.exact ~= "") then
				qw.exact = 1
			else
				qw.exact = 0
			end
			-- set index
			if (wildcards.index == "") then
				qw.index = 1
			else
				qw.index = tonumber(wildcards.index)
			end
		end
		-- set exact
		if (qw.exact == 1) then
			qw.short_name = guess_mob_keywords(qw.full_name)
		else
			qw.result_match_name = split(guess_mob_keywords(qw.full_name), "[^ ]+")[1]
		end
		-- limit to 30 chars
		qw.result_match_name = string.sub(qw.result_match_name, 1, 30)
		set_full_mob_name(qw.full_name, "quick_where_start")
		set_short_mob_name(qw.short_name, "quick_where_start")		
		set_is_exact(qw.exact, "quick_where_start")
		create_quick_where_trigger(qw.result_match_name)
		if (qw.index == 1 ) then	-- don't use 1.mob
			Execute(string.format("where %s", qw.short_name))
		else
			Execute(string.format("where %s.%s", qw.index, qw.short_name))
		end
	end
	
	function create_quick_where_trigger(mobName)
		DeleteTrigger("QuickWhereTrigger")
		--local match = string.format("(?=.*%s.*)^(?<mob>.{30}) (?<room>.+)$", string.sub(mobName, 1, 30))
		local match = "^(?<mob>.{30}) (?<room>.+)$"
		AddTriggerEx("QuickWhereTrigger", match, "", eEnabled + eKeepEvaluating + eIgnoreCase + eTriggerRegularExpression + eReplace + eTemporary, 
			-1, 0, "", "quick_where_match", 12, 20)	
	end
	function quick_where_match(name, line, wildcards)
		if (string.find(line, "There is no", 1, true) ~= nil) then
			return
		end
		local mobName = string.lower(trim(wildcards.mob))
		local parts = split(string.lower(qw.short_name), "[^ ]+")
		local found = false
		for index = 1, #parts do
			if (string.find(mobName, parts[index], 1, true) ~= nil) then
				found = true
				break -- leave loop
			else
			end
		end
		if (found == false) then	-- not our line, keep looking
			return
		end
		EnableTrigger("QuickWhereTrigger", false)
		DeleteTrigger("QuickWhereTrigger")
			local cmd = "xm {" .. qw.full_name .. "} " .. wildcards.room
			Execute(cmd)
	end
--	****** HUNT TRICK FUNCTIONS ******
	local ht = {
			full_name = "",
			short_name = "",
			exact = 1,
			index = 1
		}
	function hunt_trick(name, line, wildcards)
		EnableTriggerGroup("AutoHunt", false)
		EnableTriggerGroup("HuntTrick", true)
		local index
		if (wildcards.mob == "") then
			ht.exact = get_is_exact()
			ht.full_name = get_full_mob_name()
			ht.full_name = get_short_mob_name()
			if (ht.full_name == nil or ht.full_name == "") then
				ColourNote("#FF5000", "", "Search and Destroy: Hunt-trick has no target.")
				return
			end
			ht.index = 1
		else
			if (wildcards.exact == "x_") then
				ht.exact = 1
			else
				ht.exact = 0
			end
			set_is_exact(ht.exact, "hunt_trick")
			if (wildcards.index == "") then
				ht.index = 1
			else
				ht.index = tonumber(wildcards.index)
			end
			ht.full_name = wildcards.mob
			ht.short_name = wildcards.mob
			set_full_mob_name(ht.full_name, "hunt_trick")
			if (ht.exact == 1) then
				local guess = guess_mob_keywords(ht.full_name, true)
				ht.short_name = guess		
			end
			set_short_mob_name(ht.short_name, "hunt_trick")			
		end			
		do_hunt_trick()
	end
 	function hunt_trick_abort(name, line, wildcards)
		EnableTriggerGroup("HuntTrick", false)
		ColourNote("#FF5000", "", "Search and Destroy: Aborting Hunt Trick.")
	end
 	function hunt_trick_continue(name, line, wildcards)
		ht.index = ht.index + 1
		if (ht.index > 0 and ht.short_name ~= "") then
			do_hunt_trick()
		end
 	end
 	function hunt_trick_complete(name, line, wildcards)
		EnableTriggerGroup("AutoHunt", false)
		EnableTriggerGroup("HuntTrick", false)
		if (ht.index > 0 and get_short_mob_name() ~= "") then
			local exact = ""
			local qw_name = get_short_mob_name()
			if (ht.exact == 1) then
				exact = "x_"
				qw_name = get_full_mob_name()
			end
			HuntFoundIndex = ht.index
			if (ht.index == 1) then		-- Don't use "1.mob"
				Execute(string.format("%sqw %s", exact, qw_name))
			else
				Execute(string.format("%sqw %s.%s", exact, ht.index, qw_name))
			end
		end
 	end
	function do_hunt_trick()	-- this function is never called by trigger.  It is only called from other hunt trick functions.
		if (ht.index > 0 and get_short_mob_name() ~= "") then
			local hunt
			if (ht.index == 1) then
				hunt = string.format("hunt %s", get_short_mob_name())		-- Don't hunt 1.mob
			else
				hunt = string.format("hunt %d.%s", ht.index, get_short_mob_name())
			end
			Execute(hunt)
		end
	end
	
	function guess_mob_keywords(mobName)	--xxguess (easy 'find' text to make editing this easier)
		local mob = string.lower(mobName)
		local arid = currentRoom.arid	
		local parts = split(mobName, "[^ ]+")
		local comma = (string.find(parts[1], ",") or -1)	-- detect if we have a name like "WinkleWinkle, the coder"
			
		if ((#parts > 1) and (comma == #(parts[1]))) then	-- if the position of comma == the length of the first word, e.g. "Starling,"
			mob = string.lower(string.gsub(parts[1], ",$", ""))	 -- remove the comma from the first word.
		else		
			local clean2 = {}
			local cleanIndex = 1
			for i,v in ipairs(parts) do	--clean parts
				local clean = v
				clean = string.gsub(clean, "^[Aa]$", "")
				clean = string.gsub(clean, "^[Aa]n$", "")
				clean = string.gsub(clean, "^[Tt]he$", "")
				clean = string.gsub(clean, "^[Oo]f$", "")
				clean = string.gsub(clean, "^[Ss]ome$", "")
				
				--if (currentRoom ~= nil) then	-- area specific cleans
					if (currentRoom.arid == "bonds") then
						clean = string.gsub(clean, "^[Dd]ragon$", "")
					elseif (currentRoom.arid == "hatchling") then
						clean = string.gsub(clean, "^[Ww]help$", "")
						clean = string.gsub(clean, "^[Dd]ragon$", "")
					elseif (currentRoom.arid == "sennarre") then
						clean = string.gsub(clean, "^[Gg]ale's$", "")
					elseif (currentRoom.arid == "sirens") then
						clean = string.gsub(clean, "^[Mm]iss$", "")
					elseif (currentRoom.arid == "spyreknow") then
						clean = string.gsub(clean, "^[Ll]ittle black$", "")
					elseif (currentRoom.arid == "verume") then
						clean = string.gsub(clean, "^[Ll]izardman$", "")
					elseif (currentRoom.arid == "wooble") then
						clean = string.gsub(clean, "^[Ss]ea$", "")	
					elseif (currentRoom.arid == "sohtwo") then
						if (string.find(clean, "^[Ee]vil$") == 1 and #parts == 2) then
							parts[2] = ""
						end
						if (string.find(clean, "^[Gg]ood$") == 1 and #parts == 2) then
							parts[2] = ""
						end
					end
				--end
				clean = split(clean, "[a-zA-Z]+")
				-- tprint(clean)
				if (clean[1] ~= nil and clean[1] ~= "") then
					clean2[cleanIndex] = clean[1]
					cleanIndex = cleanIndex + 1
				end
			end
			-- tprint(clean2)
			if (#clean2 == 0) then			-- we over-guessed!  User entered "qw whelp" or something
				mob = string.lower(mobName)
			elseif (#clean2 == 1) then		-- improve variances in keywords by only using first few letters of mob name words
				mob = string.lower(string.sub(clean2[1], 1, 8))
			else
				mob = string.lower(string.sub(clean2[1], 1, 4) .. " " .. string.sub(clean2[#clean2], 1, 4))
			end
		end
		set_short_mob_name(mob, "guess_mob_keywords")
		return mob, mob
	end
--	******* AUTO HUNT FUNCTIONS *******
	function auto_hunt(name, line, wildcards)
		local mobname = string.lower(wildcards.mob)
		if (mobname == "abort") or (mobname == "0") then
			auto_hunt_abort("", "", "")
			return
		else
		EnableTriggerGroup("AutoHunt", true)
		EnableTriggerGroup("HuntTrick", false)
		auto_hunt_reset()
		autoHuntMob = mobname
		SendNoEcho("hunt " .. autoHuntMob)
		end
	end
	
	function auto_hunt_next(name, line, wildcards)
		local dir = wildcards.dir
		auto_hunt_move(dir)
		Execute("hunt " .. autoHuntMob)
		auto_hunt_reset()
	end
	
	function auto_hunt_lowskill(name, line, wildcards)
		print("")
		ColourNote("#FF5000", "", "Search and Destroy: Autohunt not available - Hunt skill is too low.")
		ColourNote("#FF5000", "", "                     If hunt skill is available, practice it to 85% or higher.")
		auto_hunt_abort("", "", "")
	end
	
	function auto_hunt_abort(name, line, wildcards)
		EnableTriggerGroup("AutoHunt", false)
		auto_hunt_reset()
		autoHuntMob = ""
		ColourNote("#FF5000", "", "Search and Destroy: Aborting auto-hunt...\n")
	end
	function auto_hunt_complete(name, line, wildcards)
		EnableTriggerGroup("AutoHunt", false)
		auto_hunt_reset()
		autoHuntMob = ""
		ColourNote("#40C040", "", "Search and Destroy: Auto-hunt complete.\n")
	end
	
	function auto_hunt_portal()
		print("")
		ColourNote("#40C040", "", "Search and Destroy: Auto-hunt through portals not working yet.  Enter portal manually and then autohunt again.")
		auto_hunt_complete("", "", "")
	end
	
	function auto_hunt_move(direction)
		local dir = dir_map[direction]
		if (currentRoom == nil) then	-- don't know our gmcp exits, so just go with it
			Execute(dir) 		
		else
			if (currentRoom.exits[dir] ~= nil) then
				if (tonumber(currentRoom.exits[dir]) == -1 ) then
					Execute(dir) 		
				else
					--Execute("xmapper move " .. currentRoom.exits[dir])
					Execute(dir)
				end
			else	--no exit?  try and open a hidden door that way
				Execute("open " .. direction)
				Execute(dir) 		
			end		
		end
	end
	function auto_hunt_reset()
		autoHuntData = { count = 0, north = 0, south = 0, east = 0, west = 0, up = 0, down = 0 }
	end
--	****** WHERE TRICK FUNCTIONS *****
	local wt = { index = 1, name = "", match = "" }
	
	function wt_continue(name, line, wildcards)	
		wt.index = wt.index + 1
		Send("wt " .. wt.index .. "." .. wt.name)
	end	
	function wt_fail(name, line, wildcards)	
		EnableTriggerGroup("wt", false)
		Note("Search and Destroy: Aborting where trick...")
	end	
	
----------- page size functions ---------------------------
	local page_size = 0
	local page_size_suspended = false
	
	function capture_page_size(name, line, wildcards)
		--Note(name .. ":" .. line .. "," .. tostring(table.concat(wildcards)))
		EnableTrigger("trg_capture_page_size", false)
		local size = tonumber(wildcards[1])
		--Note("size:" .. tostring(size) .. "-" .. tostring(wildcards[1]))
		page_size = size or 0
		--Note(page_size)
		SendNoEcho("pagesize 0")
	end
	
	function suspend_page_size(name, line, wildcards)
		if (page_size_suspended == false) then
			page_size_suspended = true
			ColourNote("#FF3030", "", "\nSearch and Destroy: Temporarily disabling pagesize (area index process)\n")
			EnableTrigger("trg_capture_page_size", true)
			EnableTrigger("trg_pagesize_gag_1", true)
			SendNoEcho("pagesize")
		end
	end	
	function resume_page_size(name, line, wildcards)
		ColourNote("#FF3030", "", "\nSearch and Destroy: Area index complete. Pagesize re-enabled (if >0)\n")
		EnableTrigger("trg_capture_page_size", false)
		if (page_size ~= 0) then
			SendNoEcho("pagesize " .. page_size)
		end
		page_size_suspended = false
	end	
-- *** former plugin - S&D GUI *** -->
	function create_win()
		if (win_init == false) then
			win_init = true
			win_width = tonumber(GetVariable("mcvar_xgui_WinSizeX")) or 280
			win_height = tonumber(GetVariable("mcvar_xgui_WinSizeY")) or 280
			WindowCreate (win, windowinfo.window_left, windowinfo.window_top, win_width, win_height, windowinfo.window_mode, windowinfo.window_flags, background_colour)  -- create window
			
			WindowShow(win, true)  -- show it 
			if (win_state == "min") then
				mouseup(0, "hsMinimize")
			end		
			
			WindowFont(win, "window_title", "Consolas", 10, false, false, false, false) 				-- title bar font
			WindowFont(win, "button_1", "Segoe", 10, true, false, false, false)						-- main button font
			WindowFont(win, "button_2", "Segoe", 10, true, false, false, false) 					-- title bar button font
			WindowFont(win, "cplevel", "Consolas", 12, false, false, false, false)							-- cp level font
			WindowFont(win, "cplist_area", "Lucida Sans Unicode", cplist_font_size, false, false, false, false)	-- cp list font, area cp's
			WindowFont(win, "cplist_room", "Segoe", cplist_font_size, false, false, false, false)					-- cp list font, room cp's
			if (IsPluginInstalled(plugin_id_z_order) and GetPluginInfo(plugin_id_z_order, 17)) then
				CallPlugin(plugin_id_z_order, "registerMiniwindow", win)
			end		
			draw_window()	
			add_resize_tag()
		end
	end
	function draw_window()
		WindowRectOp (win, miniwin.rect_fill, 0, 0, 0, 0, background_colour)				-- Clear the window, which is the first step in updating it!
		WindowRectOp (win, 2, 0, 0, 0, 17, 0x000000)						 	-- Draw title bar background and set color (almost black, "17" is height)
		WindowRectOp (win, 4, 0, 0, 0, 17, 0xE0E0E0, 0x909090)					-- Draw title bar border (left/top = light grey, right/bottom = darker grey, "17" is height)
		WindowRectOp (win, 1, 0, 0, 0, 0, 0xC0C0C0, 15)							-- Draw window border.
		WindowRectOp (win, 1, 1, 17, -1, -1, 0x000000, 15)						-- Draw colored perimeter line.
		WindowText (win, "window_title", 		-- draw the window title text and set its color
					current_sd_version,	-- window title text
					5, 0, 255, 15,				-- left (x1), top (y1), right (x2), bottom (y2) values for window title text
					0x80FFFF, 					-- colour (light yellow)
					false)						-- not unicode
		if (hotspots["hsDrag1"] == nil) then
			hotspots["hsDrag1"] = WindowAddHotspot(win, "hsDrag1", 0, 0, win_width-20, 16, -- hotspot id, rectangle (left, top, right, bottom)
						"mouseover", "cancelmouseover", "mousedown", "cancelmousedown", "mouseup", 
						"Left click = Drag title bar to move\nRight click = Send window to front/back", miniwin.cursor_arrow, 0)
			WindowDragHandler(win, "hsDrag1", "dragmove", "dragrelease", 0) 
		end
		--Main action buttons. Syntax:  draw_button_1(left, top, width, height, text, hsName, hint, text_dx, text_dy)
		draw_button_1(5, 20, 30, 25, "xcp", "hsXcp", "XCP 1", 3, 3)												-- xcp
		draw_button_1(38, 20, 30, 25, "go", "hsGo", "Go to room 1", 7, 3)										-- GO
		draw_button_1(71, 20, 30, 25, "kk", "hsKill", "Kill target mob", 8, 3)									-- KK
		draw_button_1(104, 20, 30, 25, "nx", "hsNext", "Left click = goto next\nRight click = goto prev", 7, 3)	-- NX
		draw_button_1(137, 20, 30, 25, "qs", "hsQS", "Quick-scan for target", 8, 3)								-- QS
		draw_button_1(181, 20, 30, 25, "ref", "hsRefresh", "Refresh target list (cp check)", 6, 3)				-- ref
		draw_button_1(211, 20, 30, 25, "hta", "hsHTA", "Abort hunt-trick", 5, 3)								-- hta
		draw_button_1(241, 20, 30, 25, "clr", "hsClear", "Clear target list", 6, 3)								-- clr
		
		draw_cplevel(275, 20)
		-- GUI title bar buttons. Syntax:  draw_button_2(left, top, width, height, text, hsName, hint, text_dx, text_dy)
		--draw_button_2(win_width - 17, 0, 17, 17, "?", "hsHelp", "Show help", 4, 0)			-- help
		--draw_button_2(win_width - 30, 0, 15, 17, ".", "hsMinimize", "Minimize", 5, 0)		-- minimize
		--draw_button_2(win_width - 15, 0, 15, 17, "^", "hsMaximize", "Maximize", 3, 0)		-- maximize
		--print("win_width=" .. win_width)
		Redraw()
	end
		
	function draw_button_1(left, top, width, height, text, hsName, hint, text_dx, text_dy)					-- Draw button type 1 (main action buttons)
		local x1,x2,y1,y2 = left, (left+width), top, (top+height)											-- x and y values for button boundaries
		local tx1,tx2,ty1,ty2 = (left+text_dx), (left+width-text_dx), (top+text_dy), (top+height-text_dy)	-- x and y values for text location
		local bgcolor = 0x000000
		local color_1 = 0xE0E0E0
		local color_2 = 0x808080
		WindowRectOp(win, 2, x1, y1, x2, y2, bgcolor)														-- Draw background and set color (black)
		WindowRectOp (win, 4, x1, y1, x2, y2, color_1, color_2)											-- Draw button border (left/top = light grey, right/bottom = darker grey)
		WindowText(win, "button_1", text, tx1, ty1, tx2, ty2, color_1, false)								-- Draw button text ("button" font, light grey)
		if (hotspots[hsName] == nil) then																-- Make button clickable by defining a hotspot
			hotspots[hsName] = WindowAddHotspot(win, hsName, x1, y1, x2, y2,							-- Hotspot name and location info
				"mouseover", "cancelmouseover", "mousedown_b1", "cancelmousedown", "mouseup_b1",				-- Mouse actions
				"" .. (hint or text), miniwin.cursor_hand, 0)											-- Tooltip text, cursor shape (hand)
		end
	end
	
	function draw_button_2(left, top, width, height, text, hsName, hint, text_dx, text_dy)					-- Draw button type 2 (title bar buttons)
		local x1,x2,y1,y2 = left, (left+width), top, (top+height)											-- x and y values for button boundaries
		local tx1,tx2,ty1,ty2 = (left+text_dx), (left+width-text_dx), (top+text_dy), (top+height-text_dy)	-- x and y values for text location
		WindowRectOp (win, 2, x1, y1, x2, y2, 0x000000)														-- Draw background and set color (black)
		WindowRectOp (win, 4, x1, y1, x2, y2, 0xE0E0E0,	0x808080)											-- Draw button border (left/top = light grey, right/bottom = darker grey)
		WindowText(win, "button_2", text, tx1, ty1, tx2, ty2, 0xE0C0C0, false)								-- Draw button text ("button" font, light grey)
		--if (hotspots[hsName] == nil) then																-- Make button clickable by defining a hotspot
			hotspots[hsName] = WindowAddHotspot(win, hsName, x1, y1, x2, y2,							-- Hotspot name and location info
				"mouseover", "cancelmouseover", "mousedown", "cancelmousedown", "mouseup", 				-- Mouse actions
				"" .. (hint or text), miniwin.cursor_hand, 0)											-- Tooltip text, cursor shape (hand)
		--end
	end
	function draw_cplevel(left, top)				-- Draw button type 1 (main action buttons)
		local width = 41
		local height = 25
		local x1,x2,y1,y2 = left, (left+width), top, (top+height)		-- left, right, top, bottom									-- x and y values for button boundaries
		local tdx = 3
		local tdy = 3
		local tx1,tx2,ty1,ty2 = (left+tdx), (left+width-tdy), (top+tdy), (top+height-tdy)	-- x and y values for text location
		local bgcolor = 0x000000
		local c1y = 0x00D000	-- green shade		color_1 = (new_cp_current_level == "yes") and c1y or c1n
		local c2y = 0x007800
		local c1n = 0x0010E0	-- red shade
		local c2n = 0x000880
		local c3 = (cp_type ~= "none") and 0x80FFFF or 0x0020FF		-- text (yellow)
		local color_1 = (new_cp_current_level == "yes") and c1y or c1n
		local color_2 = (new_cp_current_level == "yes") and c2y or c2n
	
		WindowRectOp(win, 2, x1, y1, x2, y2, bgcolor)												-- Draw background and set color (black)
		WindowRectOp (win, 4, x1, y1, x2, y2, color_1, color_2)											-- Draw button border (left/top = light grey, right/bottom = darker grey)
		WindowText(win, "cplevel", string.format("%3s", cp_level), tx1+4, ty1, tx2, ty2, c3, false)								-- Draw button text ("button" font, light grey)
		--if (hotspots[hsName] == nil) then																-- Make button clickable by defining a hotspot
		--	hotspots[hsName] = WindowAddHotspot(win, hsName, x1, y1, x2, y2,							-- Hotspot name and location info
		--		"mouseover", "cancelmouseover", "mousedown_b1", "cancelmousedown", "mouseup_b1",				-- Mouse actions
		--		"" .. (hint or text), miniwin.cursor_hand, 0)											-- Tooltip text, cursor shape (hand)
		--end
	end	
	
	function xgui_ClearWindow()
		draw_window()
		add_resize_tag()
		Redraw()
	end
	
	function xgui_RefreshWindow()
		--print("refresh window " .. os.clock())
		draw_window()
		add_resize_tag()
		write_items()
		Redraw()
	end
	
	function xgui_ToggleWindowDisplay(name, line, wildcards)
		local arg = wildcards.onoff
		if (arg == "on") or (arg == "show") or (arg == "1") then
			WindowShow(win, true)
			SetVariable("mcvar_xgui_window_onoff", "on")
		elseif (arg == "off") or (arg == "hide") or (arg == "0") then
			WindowShow(win, false)
			SetVariable("mcvar_xgui_window_onoff", "off")
		end
	end
	
	
	function xgui_font_size(name, line, wildcards)
		if (wildcards.size == "") then
			print("Cp list font size = " .. cplist_font_size .. "\n")
		else
			cplist_font_size = tonumber(wildcards.size)
			WindowFont(win, "cplist_area", "Lucida Sans Unicode", cplist_font_size, false, false, false, false)		-- cp list font, area cp's
			WindowFont(win, "cplist_room", "Segoe", cplist_font_size, false, false, false, false)					-- cp list font, room cp's
			print("Cp list font size set to " .. cplist_font_size .. ".\n")
			SetVariable("mcvar_xgui_font_size", cplist_font_size)
			xgui_RefreshWindow()
		end
	end
	function xgui_line_space(name, line, wildcards)
		if (wildcards.space == "") then
			print("Cp list line spacing = " .. line_spacing .. "\n")
		else
			line_spacing = tonumber(wildcards.space)
			print("Cp list line spacing set to " .. line_spacing .. ".\n")
			SetVariable("mcvar_xgui_line_spacing", line_spacing)
			xgui_RefreshWindow()
		end
	end
	--clear the cp mob list
	function clear_hotspots()
		for i,v in ipairs (itemHotspots) do
			--Note(i, v)
			WindowDeleteHotspot (win, v);
		end
		itemHotspots = {}
	end
	function write_items()
		clear_hotspots()
		if (win_state == "min") then
			return
		end
		xgui_build_target_list(cp_target_list)
	end
	function xgui_build_target_list(list)		-- builds the list to be displayed in the window
		local index = 0
		for i,v in ipairs (list) do		-- Abort loop if printed item would not be visible.
			if (tonumber(i) * line_spacing + offset > win_height - 5) then break end
			index = v.ord		
			local is_dead = ((v.is_dead == "yes") and "yes" or "no")
			local mobText = ((is_dead == "yes") and v.mob .. " [Dead]" or v.mob)
			
			local place			-- the room or area name, or both
			local tooltipText	-- mouseover text
			local eventHandler	-- what happens when you click a link
			
			local color = "0x0000FF"	-- red
			
			if (is_dead == "yes") then
				color = "0x505050"		-- darkish grey
			elseif (index == xcp_index) then
				color = "0x0060FF"		-- orange 
			else
				color = "0xD0D0D0"		-- very light grey
			end
			
			if (v.type == "area") then
				place = string.format("%s", v.arid)
				tooltipText = "(" .. i .. ") " .. mobText .. " - " .. v.arid
				eventHandler = "mouseup_cp"	
			elseif (v.type == "room") then
				place = string.format("'%s' (%s) [%s+]", v.roomName, v.arid, v.minlvl)
				tooltipText = "(" .. i .. ") " .. mobText .. " - " .. v.arid
				eventHandler = "mouseup_cp"
			elseif (v.type == "unknown_area") then	-- area not in mapper db
				place = string.format("area '%s' not mapped", v.location)
				color = ((is_dead == "yes") and "0x000040" or "0x0000E8")
				tooltipText = "(" .. i .. ") " .. mobText .. " - " .. v.location
				eventHandler = ""
			elseif (v.type == "unknown_room") then	-- room not in mapper db
				place = string.format("room '%s' not mapped", v.location)
				color = ((is_dead == "yes") and "0x000040" or "0x0000E8")
				tooltipText = "(" .. i .. ") " .. mobText .. " - " .. v.location
				eventHandler = ""	
			end
			
			local displayText = string.format("%s)  %s - %s", index, mobText, place)
			local displayFont = "cplist_" .. cp_type	
			
			width   = WindowTextWidth(win, displayFont, displayText)  -- width of text
			height  = WindowFontInfo(win, displayFont, 1)   -- height of the font
			ascent  = WindowFontInfo(win, displayFont, 2)   -- ascent (amount above the baseline)
			descent = WindowFontInfo(win, displayFont, 3)   -- descent (amount below the baseline)
			leading = WindowFontInfo(win, displayFont, 4)   -- leading (space above the highest letter)
			--Note(string.format("w:%s h:%s asc:%s desc:%s lead:%s", width, height, ascent, descent, leading)) 		
			
			local hsTop = (tonumber(i) * line_spacing)
			local hsLength = (10 + width)
			if (hsLength < 0) then hsLength = 0 end
			local hsHeight = (hsTop + 12 + offset)
			if (hsHeight < 0) then hsHeight = 0 end
			--if hsTop < 16 then offset = (offset + 16 - hsTop) end
			
			WindowText (win, displayFont, displayText,		-- displays the target links
						10, hsTop + offset - 5, 0, 0,		-- rectangle of link hotspot
						color,								-- color set according to above
						false)								-- not Unicode
			if (hsHeight < 0) then 
				hsHeight = 0
			elseif (hsTop + offset + hsHeight > win_height - RESIZE_TAG_SIZE) then
				-- Prevent list item's hotspot from overlapping with the resize tag
				if (hsLength > win_width - RESIZE_TAG_SIZE) then hsLength = win_width - RESIZE_TAG_SIZE end
			end
			--Note(string.format("%s %s %s %s", 5, (tonumber(i) * line_spacing) + offset, hsLength, hsHeight))
			
			itemHotspots[#itemHotspots+1] = i
			WindowAddHotspot(win, 
							i,  -- HS id
							10, hsTop + offset, hsLength, hsHeight, -- rectangle
							"mouseover", 
							"cancelmouseover", 
							"mousedown",
							"cancelmousedown", 
							eventHandler, 
							tooltipText,  -- tooltip text
							miniwin.cursor_hand, 0)  -- hand cursor
		end
	end
	function ResizeMoveCallback()
		if GetPluginVariable("c293f9e7f04dde889f65cb90", "lock_down_miniwindows") == "1" then
			return
		end
		posx, posy = WindowInfo (win, 17), WindowInfo (win, 18)
		win_width = win_width + posx - startx
		startx = posx
		if (win_width < win_minimum_width) then
			win_width = win_minimum_width
			startx = windowinfo.window_left+win_width
		elseif (win_width > GetInfo(281) - 100) then
			win_width = GetInfo(281) - 100
			startx = windowinfo.window_left+win_width
		end
		win_height = win_height + posy - starty
		starty = posy
		if (win_height < win_minimum_height) then
			win_height = win_minimum_height
			starty = windowinfo.window_top+win_height
		elseif (win_height > GetInfo(280) - 60) then
			win_height = GetInfo(280) - 60
			starty = GetInfo(280)
		end
		WindowResize(win, win_width, win_height, background_colour)
		if (utils.timer() - lastRefresh > REFRESH_DELAY) then
			xgui_RefreshWindow()
			lastRefresh = utils.timer()
		end
	end
	lastRefresh = 0
	function ResizeReleaseCallback()
		win_state = "max"
		win_height_maximized = win_height
		win_width_maximized = win_width
		hotspots["hsDrag1"] = WindowAddHotspot(win, "hsDrag1", 0, 0, win_width-20, 16, -- hotspot id, rectangle (left, top, right, bottom)
					"mouseover", "cancelmouseover", "mousedown", "cancelmousedown", "mouseup", 
					"Left click = Drag title bar to move\nRight click = Send window to front/back", miniwin.cursor_arrow, 0)	
		WindowDragHandler(win, "hsDrag1", "dragmove", "dragrelease", 0)
		xgui_RefreshWindow()
	end
	
	function add_resize_tag()
		
		local c1 = 0x484848
		local c2 = 0x909090
		--local resize_bottom = win_height - 4
		--local resize_right = win_width - 4
		local x1 = win_width - 5		-- bottom of resize widget tag
		local y1 = win_height - 5
		local x2 = win_width - 5
		local y2 = win_height - 5
		-- draw the resize widget bottom right corner, if not minimized
		--if (win_state == "max") then
			
			--WindowLine(win, win_width-3,  resize_bottom, resize_right, win_height-3, resize_color_1, 0, 1)
			WindowLine(win, x1-0, y1, x2+1, y2-1, c2, 0, 1)
			
			WindowLine(win, x1-2, y1, x2+1, y2-3, c1, 0, 1)
			WindowLine(win, x1-3, y1, x2+1, y2-4, c2, 0, 1)
			
			WindowLine(win, x1-5, y1, x2+1, y2-6, c1, 0, 1)
			WindowLine(win, x1-6, y1, x2+1, y2-7, c2, 0, 1)
			
			WindowLine(win, x1-8, y1, x2+1, y2-9, c1, 0, 1)
			WindowLine(win, x1-9, y1, x2+1, y2-10, c2, 0, 1)
			
			WindowLine(win, x1-11, y1, x2+1, y2-12, c1, 0, 1)
			WindowLine(win, x1-12, y1, x2+1, y2-13, c2, 0, 1)
		--end
		-- Hotspot for resizer.
		if (WindowHotspotInfo(win, "hsResize", 1) == nil) then
			WindowAddHotspot(win, "hsResize", win_width-RESIZE_TAG_SIZE, win_height-RESIZE_TAG_SIZE, win_width, win_height, "", "", "mousedown_resize_window", "", "", "", 6, 0)
			WindowDragHandler(win, "hsResize", "ResizeMoveCallback", "ResizeReleaseCallback", 0)
		else
			WindowMoveHotspot(win, "hsResize", win_width-RESIZE_TAG_SIZE, win_height-RESIZE_TAG_SIZE, 0, 0)
		end
	end
	function mousedown_resize_window(flags, hotspot_id)
	   if (hotspot_id == "hsResize") then
		  startx, starty = WindowInfo (win, 17), WindowInfo (win, 18)
	   end
	end
	function mouseup_b1(flags, hotspot_id)
		local click = ((bit.band(flags, 0x20) == 0) and "L" or "R")
		if (hotspot_id == "hsXcp") then	Execute("xcp 1")	-- XCP button
		elseif (hotspot_id == "hsGo") then Execute("go")	-- GO button
		elseif (hotspot_id == "hsNext") then Execute(((click == "L") and "nx" or"nx-"))	-- NX button
		elseif (hotspot_id == "hsQS") then Execute("qs")	-- QS button	
		elseif (hotspot_id == "hsKill") then Execute("kk")	-- KK button
		elseif (hotspot_id == "hsHTA") then Execute("hta")	-- HTA button
		elseif (hotspot_id == "hsRefresh") then	-- REF button
			Execute("cp ch")
			mouseup(0, "hsMaximize")
		elseif (hotspot_id == "hsClear") then	-- CLR button
			xgui_ClearWindow()
		end
	end
	function mousedown_b1()
	end
	
	function mouseup(flags, hotspot_id)
		if (hotspot_id == "hsDrag1") then		-- Title bar
			if bit.band(flags, 0x20) == 0 then	-- left click
				local nothing
			else								-- right click
				right_click_menu()
			end
		elseif (hotspot_id == "hsHelp") then
			Execute("ww help")
		end
	end
	function mouseup_cp(flags, hotspot_id)
		if (tonumber(hotspot_id) ~= nil) then
			Execute("xcp " .. hotspot_id)
		end
	end
	function right_click_menu()
		menustring = ("Bring To Front|Send To Back|Collapse Window|Expand Window")
		result = WindowMenu (win,
			WindowInfo (win, 14),		-- x position
			WindowInfo (win, 15),		-- y position
			menustring)					-- content
		if (result == "Bring To Front") then
			CallPlugin(plugin_id_z_order,"boostMe", win)
		elseif (result == "Send To Back") then
			CallPlugin(plugin_id_z_order,"dropMe", win)
		elseif (result == "Collapse Window") then
			win_state = "min"
			win_height = win_height_minimized
			WindowResize(win, win_width, win_height, ColourNameToRGB("black"))
			draw_window()
			write_items()
			add_resize_tag()
			Redraw()	
		elseif (result == "Expand Window") then
			win_state = "max"
			win_height = win_height_maximized
			WindowResize(win, win_width, win_height, ColourNameToRGB("black"))
			xgui_RefreshWindow()	
		end
	end
	function bringToFront(name, line, wildcards)
		CallPlugin(plugin_id_z_order,"boostMe", win)
	end
	function do_trg_cp_complete(name, line, wildcards) 
			mouseup(0, "hsClear")
	end
	function dragmove(flags, hotspot_id)
		if bit.band(flags, 0x20) == 0 then
			pos_x = WindowInfo(win, 17) - 50
			pos_y = WindowInfo(win, 18) - 7
			local max_x = GetInfo(281) - 100
			local max_y = GetInfo(280) - 60
			if (pos_x <= 1) then 			-- Prevents window from leaving the screen.
				pos_x = 1
			elseif (pos_x >= max_x) then 	
				pos_x = max_x
			end
			if (pos_y <= 1) then 			
				pos_y = 1
			elseif (pos_y >= max_y) then 	
				pos_y = max_y
			end
			WindowPosition(win, pos_x, pos_y, miniwin.pos_stretch_to_view, miniwin.create_absolute_location) -- move window to new location
		else
			return
		end
	end
	function dragrelease(flags, hotspot_id)
	--  print ("mouse drag release for " .. hotspot_id)
	--  print ("released at position", WindowInfo (win, 17), WindowInfo (win, 18))
	end
	
	function OnPluginSaveState()		-- save plugin state data
		-- save window location
		movewindow.save_state (win)		
		if WindowInfo(win, 3) and WindowInfo(win, 4) then
			win_width = WindowInfo(win, 3)
			win_height = WindowInfo(win, 4)
		end
		SetVariable("mcvar_xgui_WinPosX", pos_x)
		SetVariable("mcvar_xgui_WinPosY", pos_y)
		SetVariable("mcvar_xgui_WinState", win_state)
		SetVariable("mcvar_xgui_WinSizeX", win_width)
		SetVariable("mcvar_xgui_WinSizeY", win_height)
		SetVariable("mcvar_xgui_WinMaxX", win_width_maximized)
		SetVariable("mcvar_xgui_WinMaxY", win_height_maximized)
	end
	
	function OnPluginClose()
		OnPluginSaveState()
		WindowShow(win, false) 			-- hide window, refresh screen
	end 
-- Internal Utilities
	function dbcheck(code)
		if code ~= sqlite3.OK and    -- no error
			code ~= sqlite3.ROW and   -- completed OK with another row of data
			code ~= sqlite3.DONE then -- completed OK, no more rows
			local err = db:errmsg ()  -- the rollback will change the error message
			db:exec("ROLLBACK")      -- rollback any transaction to unlock the database
			error (err, 2)            -- show error in caller's context
		end
	end
	function fixbool(b)
		if b then
			return 1
		else
			return 0
		end
	end
	
	function fixsql(s)
		if s then
			return "'" .. (string.gsub (s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
		else
			return "NULL"
		end
	end
	function padRight(text, length, padChar)
		local padding = length - string.len(text)
		for i = 1, padding do
			text = text .. padChar
		end
		return text
	end	
	
	function quote(str)
		return "\""..str.."\""
	end
	
	function sanitize_filename(str)
		str = string.gsub(str, "[^%w%s()_-]", "")
		return str
	end
	function spairs(t, f)
		local a = {}
		for n in pairs(t) do 
			table.insert(a, n)
		end
		table.sort(a, f)
		local i = 0      -- iterator variable
		local iter = function ()   -- iterator function
			i = i + 1
			if a[i] == nil then
				return nil
			else
				return a[i], t[a[i]]
			end
		end
		return iter
    end
	function split(line, delim)
		local result = {}
		local index = 1
		for token in string.gmatch(line, delim) do
			result[index] = token
			index = index + 1
		end
		return result
	end
	function trim(s)
	  return s:match'^()%s*$' and '' or s:match'^%s*(.*%S)'
	end
--[[	
	function IGuessMobNameBroadcast(mobName, arid)
		set_full_mob_name(mobName, "IGuessMobNameBroadcast")
		local mobName, mobSub = guess_mob_keywords(mobName, true, arid)
		if (mobSub == nil) then
			--set_short_mob_name(mobName, "IGuessMobNameBroadcast")
			return mobName, nil
		else
			--set_short_mob_name(mobSub, "IGuessMobNameBroadcast")
			return mobName, serialize.save_simple(mobSub)
		end
	end
	
	function IGuessMobNameNoBroadcast(mobName, arid)
		local mobName, mobSub = guess_mob_keywords(mobName, false, arid)
		if (mobSub == nil) then
			return mobName, nil
		else
			return mobName, serialize.save_simple(mobSub)
		end
	end
]]
	----------- EXTERNAL CALLOUTS -----------------------------
--[[
	function remote_guess_mob_keywords(mobName, arid, broadcast)
		local rc, mobGuess, subMob = CallPlugin(
			plugin_id_search_destroy, 
			"IGuessMobNameBroadcast", 
			mobName,
			arid)
		if (subMob ~= nil) then
		end
		return mobGuess
	end
]]
]]>
</script>

<triggers>
	<!-- Campaign Triggers -->	
	<trigger name="trg_cp_request" group="trg_campaign"
		match="^.+ tells you \'Good luck in your campaign\!\'$"
		script="player_start_new_cp"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>
	
	<trigger name="trg_cp_check_line" group="trg_campaign"
		match="^You still have to kill \* (?<mob>[^(]+) \((?<loc>.+?)(?<isdead> - Dead)?\)$"
		script="cp_check_line"
		enabled="n"	regexp="y" sequence="500" omit_from_output="y" send_to="12" > 
			<send>
				EnableTrigger("trg_cp_check_end", true) </send> </trigger>

	<trigger name="trg_cp_check_end" group="trg_campaign"
		match="^(?!You still have to kill \*)"
		script="cp_check_end"
		enabled="n"	regexp="y" sequence="500" omit_from_output="n" send_to="12" >
			<send>
				EnableTrigger("trg_cp_check_line", false)
				EnableTrigger("trg_cp_check_end", false) </send> </trigger>
	
	<trigger name="trg_cp_mob_killed" group="trg_campaign"
		match="^Congratulations, that was one of your CAMPAIGN mobs\!$"
		script="cp_mob_killed"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger name="trg_player_not_on_cp" group="trg_campaign"
		match="^You are not currently on a campaign\.$"
		script="player_not_on_cp"
		enabled="y"	regexp="y" sequence="100" send_to="12" > </trigger>

	<trigger name="trg_player_is_on_cp"
		match="^You have (?:(?:\d+ day(?:s)?, )?\d+ hour(?:s)? and )?\d+ minute(?:s)? left to finish this campaign\.$"
		script="player_is_on_cp"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>
		
	<trigger name="trg_cp_check_scrambled_gag" group="trg_campaign"
		match="^Note\: One or more target names in this campaign might be slightly scrambled\.$"
		script=""
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" > </trigger>	
	
	<trigger name="trg_cp_check_dead_gag" group="trg_campaign"
		match="^Note\: Dead means that the target is dead, not that you have killed it\.$"
		script=""
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" > </trigger>

	<!-- area indexing triggers -->
	<trigger name="trg_area_index_start"
		match="^              \[ Listing all areas in range 1 to 300 \]$"
		script="area_index_start"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" >
			<send>
				EnableTrigger("trg_area_index_gag_headers", true)
				EnableTrigger("trg_area_index_gag_header_lines", true)
				EnableTrigger("trg_area_index_line", true)
				EnableTrigger("trg_area_index_gag_lock_means", true)
				EnableTrigger("trg_area_index_end", true) </send> </trigger>

	<trigger name="trg_area_index_gag_headers"
		match="^From To   Lock  Keyword          Area Name"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" >
			<send>
				EnableTrigger("trg_area_index_gag_headers", false) </send> </trigger>
	
	<trigger name="trg_area_index_gag_header_lines"
		match="---- ---- ----  ---------------  ------------------------------"
		enabled="n" regexp="n" sequence="100" omit_from_output="y" send_to="12" >
			<send>
				EnableTrigger("trg_area_index_gag_header_lines", false) </send> </trigger>

	<trigger name="trg_area_index_line"
		match="^\s+(?<min>\d+)\s+(?<max>\d+)\s+(?<lock>\d+)?\s+?(?<arid>.+?)\s+(?<areaName>.+?)$"
		script="area_index_line"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger name="trg_area_index_gag_lock_means"
		match="'Lock' means you cannot enter until you are that level or higher."
		enabled="n" regexp="n" sequence="100" omit_from_output="y" send_to="12" >
			<send>
				EnableTrigger("trg_area_index_gag_lock_means", false) </send> </trigger>

	<trigger name="trg_area_index_end"
		match="---------------------------------------------------------------"
		script="area_index_end"
		enabled="n" regexp="n" sequence="100" omit_from_output="y" keep_evaluating="y" send_to="12" >
			<send>
				EnableTrigger("trg_area_index_line", false)
				EnableTrigger("trg_area_index_end", false) </send> </trigger>

	<!-- CAMPAIGN INFO PROCESSING -->
	<trigger name="trg_cp_info_level_taken" group="trg_campaign"
		match="^Level Taken\.\.\.\.\.\.\.\.\: \[\s+(?<level>[1-2]?\d{1,2}) \]$"
		script="cp_level_taken"		
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>
				EnableTrigger("trg_cp_info_level_taken", false)</send> </trigger>
	
	<trigger name="trg_cp_info_targets" group="trg_campaign"
		match="^The targets for this campaign are\:$"
		script=""
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>
				EnableTrigger("trg_cp_info_targets", false)
				EnableTrigger("trg_cp_info_line", true)
				EnableTrigger("trg_cp_info_end", true) </send> </trigger>
	
	<trigger name="trg_cp_info_line" group="trg_campaign"
		match="^Find and kill 1 \* (?<mob>.+) \((?<loc>.+)\)$"
		script="cp_info_line"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger name="trg_cp_info_end" group="trg_campaign"
		match="^(?!Find and kill 1 \*)"
		script="cp_info_end"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>
				EnableTrigger("trg_cp_info_line", false)
				EnableTrigger("trg_cp_info_end", false) </send> </trigger>

	<!-- CAMPAIGN STATUS TRACKING -->
	<trigger
		match="CONGRATULATIONS! You have completed your campaign."
		script="player_not_on_cp"
		name="sd_trg_cp_complete"
		enabled="y" regexp="n" sequence="100" keep_evaluating="y"> </trigger>
	
	<!-- HUNT TRICK -->
	<trigger
		match="^You are (?:almost )?certain that .+ is (?:north|south|east|west|up|down) from here\.|You are confident that .+ passed through here, heading (?:north|south|east|west|up|down)\.|The trail of .+ is confusing, but you're reasonably sure .+ headed (?:north|south|east|west|up|down)\.|There are traces of .+ having been here. Perhaps they lead (?:north|south|east|west|up|down)\?|You have no idea what you\'re doing\, but maybe .+ is (?:north|south|east|west|up|down)\?|You couldn\'t find a path to .+ from here\.|.+ is here\!$"
		script="hunt_trick_continue"
		name="trg_hunt_trick_continue_dir" group="HuntTrick"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger
		match="^You are (?:almost )?certain that .+ is through .+\.|You are confident that .+ passed through here, heading through .+\.|The trail of .+ is confusing, but you're reasonably sure .+ headed through .+\.|There are traces of .+ having been here\. Perhaps they lead through .+\?|You have no idea which way .+ went\.$"
		script="hunt_trick_continue"
		name="trg_hunt_trick_continue_portal" group="HuntTrick"
		enabled="n" regexp="y" sequence="100" > </trigger>
	
	<trigger
		match="^You seem unable to hunt that target for some reason\.$"
		script="hunt_trick_complete"
		name="trg_hunt_trick_complete" group="HuntTrick"
		enabled="n" regexp="y" sequence="100" > </trigger>
	
	<trigger name="trg_hunt_trick_continue_2" group="HuntTrick"
		match="^.+ is here\!$"
		script="hunt_trick_continue"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger name="trg_hunt_trick_abort" group="HuntTrick"
		match="^No one in this area by the name '.+'\.|No one in this area by that name\.|Not while you are fighting\!|You can't hunt while (?:resting|sitting)\.|You dream about going on a nice hunting trip, with pony rides, and campfires too\.$"
		script="hunt_trick_abort"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<!--  AUTO HUNT -->
	<trigger name="trg_autohunt_next_1" group="AutoHunt"
		match="^You are (?:almost )?certain that (?<mob>.+) is (?<dir>.+) from here\.$"
		script="auto_hunt_next"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger name="trg_autohunt_next_2" group="AutoHunt"
		match="^You are confident that (?<mob>.+) passed through here\, heading (?<dir>.+)\.$"
		script="auto_hunt_next"
		enabled="n" regexp="y" sequence="100" > </trigger>

 	<trigger name="trg_autohunt_lowskill" group="AutoHunt"
		match="^The trail of .+ is confusing, but you\'re reasonably sure .+ headed (?:north|south|east|west|up|down)\.|There are traces of .+ having been here\. Perhaps they lead (?:north|south|east|west|up|down)\?|You have no idea what you\'re doing, but maybe .+ is (?:north|south|east|west|up|down)\?$"
		script="auto_hunt_lowskill"	
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger name="trg_autohunt_portal" group="AutoHunt"
		match="^You are (?:almost )?certain that .+ is through .+\.|You are confident that .+ passed through here, heading through .+\.|The trail of .+ is confusing, but you're reasonably sure .+ headed through .+\.|There are traces of .+ having been here\. Perhaps they lead through .+\?|You have no idea what you\'re doing\, but maybe .+ is through .+\?$"
		script="auto_hunt_portal"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger name="trg_autohunt_abort" group="AutoHunt"
		match="^No one in this area by the name '.+'\.|You couldn\'t find a path to .+ from here\.|No one in this area by that name\.|Not while you are fighting\!|You can't hunt while (?:resting|sitting)\.|You dream about going on a nice hunting trip, with pony rides, and campfires too\.$"
		script="auto_hunt_abort"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger name="trg_hunt_trick" group="AutoHunt"
		match="^You seem unable to hunt that target for some reason\.$"
		script="auto_hunt_abort"
		enabled="n" regexp="y" sequence="100" > </trigger>
	
	<trigger name="trg_autohunt_complete" group="AutoHunt"
		match="^.+ is here\!$"
		script="auto_hunt_complete"
		enabled="n" regexp="y" sequence="100" > </trigger>
	
	<!-- page size -->
	<trigger name="trg_capture_page_size"
		match="^You currently display ([0-9]+) lines per page\.|You do not page long messages\.$"
		script="capture_page_size"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" omit_from_output = "y" > </trigger>
	
	<trigger name="trg_pagesize_gag_1"
		match="^Use 'pagesize \<lines\>' to change, or 'pagesize 0' to disable paging\.$"
		script=""
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" omit_from_output = "y" send_to="12" >
			<send>
				EnableTrigger("trg_pagesize_gag_1", false) </send> </trigger>
	
	<!-- WHERE TRICK -->
	<trigger name="trg_wt_fail" group="wt"
		match="^There is no [0-9]+\..+ around here\.$"
		script="wt_fail"
		enabled="n" regexp="y" sequence="100" > </trigger>
	
	<trigger name="trg_wt_continue" group="wt"
		match="^(?<mob>.{30}) (?<room>.+)$"
		script="wt_continue"
		enabled="n" regexp="y" sequence="100" > </trigger>
	
	<!-- AUTO SET NOEXP -->
	<trigger name="trg_noexp_manual_toggle"
		match="^(?:You will no longer receive experience\. Happy questing\!|You will now receive experience\. Happy leveling\!)$"
		script="noexp_manual_toggle"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>
	
	<trigger name="trg_mobkill_awards_xp"		 
		match="^You (?:don't )?receive (\d+)(?:\+\d+)? experience points?\.$"
		script="mobkill_awards_xp"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger name="trg_noexp_raise_level"
		match="^You raise a level\! You are now level \d+\.$"
		script="noexp_raise_level"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y"> </trigger>
	
	<trigger name="trg_cp_check_noexp"
		match="You may take a campaign at this level."
		script="cp_check_noexp"
		enabled="y" regexp="n" sequence="100" > </trigger>

	<trigger name="trg_new_cp_must_level"
		match="You will have to level before you can go on another campaign."
		script="new_cp_must_level"
		enabled="y" regexp="n" sequence="100" keep_evaluating="y" > </trigger>

	<!-- Other triggers -->
	<trigger name="trg_gag_all"
		match="^$"
		script=""
		enabled="n" regexp="n" sequence="100" keep_evaluating="y" omit_from_output="y" > </trigger>

	<trigger name="gui_trg_cp_complete"
		match="CONGRATULATIONS! You have completed your campaign."
		script="do_trg_cp_complete"
		enabled="y" sequence="100" > </trigger>
	
	<trigger name="trg_cp_quit"
		match="Campaign cleared."
		script="do_trg_cp_complete"
		enabled="y" sequence="100" > </trigger>
</triggers>

<aliases>
	<!-- help section, need to redo this -->
<alias	match="^(?:ww|extender) help$"
		script=""  name="old_help_1"
		enabled="n" regexp="y" sequence="100" ignore_case="y" send_to="12" keep_evaluating="y" >
			<send>	ColourNote("MediumSeaGreen", "", GetPluginInfo (GetPluginID (), 3)) </send> </alias>

	<alias name="old_help_2"
		match="^(?:ww|search|xset) help$"
		enabled="n" regexp="y" sequence="100" ignore_case="y" keep_evaluating="y" send_to="12" >
			<send>	ColourNote("SteelBlue", "", GetPluginInfo (GetPluginID (), 3)) </send> </alias>
				
	<alias 
		match="^xcp$"
		script="xcp_noarg"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>
		
	<alias 
		match="^xcp (?<index>[0-9]+)$"
		script="xcp_arg"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>
	
	<alias 
		match="^xcp mode(?: (?<option>ht|qw|off))?$"
		script="option_set_xcp_mode"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias
		match="^(?:xrt|xrun|xrunto) (?<loc>.+)$"
		script="xrun_to"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>
	
	<alias 
		match="^cp (?<arg>ch|check|test)$"
		script="cp_check_start"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" >
			<send>
				EnableTrigger("trg_cp_check_line", true) </send> </alias>
	
	<alias 
		match="^(?:go|goto)( (?<id>[0-9]+))?$"
		script="goto_number"
		enabled="y" regexp="y" sequence="100" ignore_case="y" keep_evaluating="y" > </alias>

	<alias 
		match="^nx$"
		script="goto_next"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>
	
	<alias 
		match="^nx-$"
		script="goto_previous"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>


	
	<alias
		match="^(?:xmapper|xmap|xm) move (?<roomid>[0-9]+|-1) ?(?<speed>run|walk)?$"
		script="move_trigger"
			enabled="y" regexp="y" sequence="95" ignore_case="y" > </alias>
	
	<alias
		match="^xm(?:\ {(?<mob>[^\}]+)\})? (?<loc>.+)$"
		script="map_area"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>

	<alias
		match="^xmall(?:\ {(?<mob>[^\}]+)\})? (?<loc>.+)$"
		script="map_area_all"
		enabled="y" regexp="y" sequence="99" ignore_case="y" > </alias>
	
	<!-- roomnotes -->
	<alias
		match="^(?:roomnote|rn)$"
		script="room_note"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>

	<alias
		match="^(?:roomnote|rn) a(?:rea)?(?: (?<arid>.+))?$"
		script="room_note_area"
		enabled="y" regexp="y" sequence="99" ignore_case="y" > </alias>

	<!-- Sql Execution -->
	<alias 
		match="^runsql (?<sql>.+)$"
		script="RunSql"
		enabled="y" regexp="y" sequence="1" ignore_case="y" > </alias>

    <alias
		match="^execsql (?<sql>.+)$"
		script="ExecSql"
		enabled="y" regexp="y" sequence="1" ignore_case="y" > </alias>
	
	<alias
		match="^simulate cp$"
		script="cp_simulate"
		enabled="y" regexp="y" sequence="1" ignore_case="y" > </alias>
	
	<!-- xset commands -->
	<alias
		match="^xset pk$"
		script="xset_pk"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>

	<alias 
		match="^xset mark$"
		script="xset_to_mark"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>

<alias  match="^xset vidblain$"
		script="xset_vidblain_onoff"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>
	
<alias  match="^xset vidblain (?<level>\d{1,3})$"
		script="xset_vidblain_setlevel"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>

<alias  match="^xset speed ?(?<speed>run|walk)?$"
		script="set_speed"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>
	<!-- Campaign commands -->
	<alias 
		match="^cp (?:i|info)$"
		script="cp_info_start"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" >
			<send>
				EnableTrigger("trg_cp_info_level_taken", true)
				EnableTrigger("trg_cp_info_targets", true) </send> </alias>
	
	<!-- Quest commands -->
	<alias name="xquest_info"
		match="^(?:xq|xq1)$"
		script="xquest_1"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>

	<!-- Quick scan commands-->
	<alias name="cmd_QuickScan"
		match="^qs$"
		script="quick_scan"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>

	<!-- Auto hunt commands-->
	<alias name="cmd_AutoHunt"
		match="^ah (?<mob>.+)$"
		script="auto_hunt"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>

	<alias name="cmd_AutoHuntAbort_2"
		match="^(?:aha|ah0)$"
		script="auto_hunt_abort"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>

	<!-- Hunt trick commands -->
	<alias name="cmd_hunt_trick" group="HuntTrick"
		match="^(?<exact>x_)?ht(?!tp) ?(?:(?<index>[0-9]+)(?:[.\s]))?(?:(?<mob>.+))?$"
		script="hunt_trick"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>
	
	<alias name="cmd_hunt_trick_2" group="HuntTrick"
		match="^xht (?:(?<index>[0-9]+)(?:[.\s]))?(?:(?<mob>.+))?$"
		script="hunt_trick"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>

	<alias name="HuntTrickAbort_2" group="HuntTrick"
		match="^(?:hta|ht0|ht abort|ht 0)$"
		script="hunt_trick_abort"
		enabled="y" regexp="y" sequence="95" ignore_case="y" > </alias>	
	
	<!-- Quick-kill commands: qk, ak, kk, xset attack -->
	<alias name="cmd_QuickKill"
		match="^(?:quick kill|ak|kk|qk)$"
		script="quick_kill"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>
	
	<alias name="cmd_xset_quick_kill_command"
		match="^xset (?:kill)( (?<arg>.+))?$"
		script="xset_quick_kill_command"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>
		
	<!-- Quick where, xwhere -->
	<alias name="cmd_QuickWhere"
		match="^(?<exact>x_)?qw( (?:(?<index>[0-9]+)\.)?(?<mob>.+)?)?$"
		script="quick_where_start"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>
	
	<alias
		match="^(?:xw|xwh|xwhere)( (?<n1>\d+))?( (?<n2>\d+))?( (?<mob>.+))?$"
		script="do_xwhere"
		name="cmd_xwhere"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>

	<!-- Auto noexp -->
	<alias
		match="^xset noexp( (?<arg>off|[0-9]+))?$"
		script="xset_noexp_tnl"
		name="cmd_xset_noexp_tnl"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>
	
	<!-- Page Size -->
	<alias
		match="^xset suspend page size$"
		script="suspend_page_size"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>

	<alias
		match="^xset resume page size$"
		script="resume_page_size"
		enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>

	<alias name="xgui_fontsize"
		match="^(?:xgui|xset) fontsize( (?<size>[0-9]+))?$"
		script="xgui_font_size"
		enabled="y" regexp="y" sequence="100"> </alias>
	
	<alias name="xgui_linespace"
		match="^(?:xgui|xset) linespace( (?<space>[0-9]+))?$"
		script="xgui_line_space"
		enabled="y" regexp="y" sequence="100" > </alias>
	
	<alias name="xgui_window_reset"
		match="^(?:xgui|xset) winreset$"
		script="create_win"
		enabled="y" regexp="y" sequence="100" send_to="12" >
			<send>
				win_init = false</send> </alias>

	<alias name="xgui_window_front"
		match="^(?:xgui|xset) front$"
		script="bringToFront"
		enabled="y" regexp="y" sequence="100" > </alias>
		
	<alias name="xgui_toggle_window_show"
		match="^(?:xgui|xset) window (?<onoff>on|show|1|off|hide|0)$"
		script="xgui_ToggleWindowDisplay"
		enabled="y" regexp="y" sequence="100" > </alias>
</aliases>
</muclient>